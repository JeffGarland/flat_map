\section{Motivation and Scope}

There has been a strong desire for a more space- and/or runtime-efficient
representation for \code{map} among C++ users for some time now.  This has
motivated discussions among the members of SG14 resulting in a
paper\footnote{See P0038R0,
  \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0038r0.html}{here}.},
numerous articles and talks, and an implementation in Boost,
\code{boost::container::flat_map}\footnote{Part of Boost.Container,
  \href{http://www.boost.org/doc/libs/1_61_0/doc/html/container.html}{here}.}.
Virtually everyone who makes games, embedded, or system software in C++ uses
the Boost implementation or one that they rolled themselves.\\

Here are some numbers that show why.  The graphs that follow show runtimes for
different \code{map}-like associative containers.  The containers used are
Boost.FlatMap, \code{map}, \code{unordered_map}, and two thin wrappers over a
sorted \code{vector}.  The ``custom pair'' version of the sorted \code{vector}
uses a simple \code{struct} instead of \code{pair} for its value type.  All
containers use either \code{<int, int>} or \code{<std::string, std::string>}
for the value type.\\

All data in the graphs below were produced on Windows with MSVC 2015, on Linux
with Clang 3.8 and libc++, or on Linux with g++ 4.8.4 and libstdc++.\\

Each set of six graphs shows the performance of a single operation on all
map-variants.  The left column shows the \code{<int, int>} runs, and the right
column shows the \code{<std::string, std::string>} ones.  Each row shows one
platform/compiler configuration. \\

These four sets of graphs cover the most commonly-used operations.  The first
set shows insertion of N elements with random keys; the second shows full
iteration across all N elements; the third shows \code{map.find()} called once
for each key used in the original insertions; and the fourth shows erasure of
all N elements, by the keys used in the original insertions.\\

\subsection{Insert}

%%% insert, int, string %%%

Unsurprisingly, insertion takes longer in contiguous-storage implementations.
Boost.FlatMap and a sorted \code{vector<pair<int, int>>} have the steepest
growth curves.  The curve for sorted \code{vector} using a custom
\code{struct} is dramatically flatter in its growth in the \code{<int, int>}
runs.  Note that the custom-pair vector does about the same as the
\code{vector} of \code{pair} in the \code{<std::string, std::string>} runs.

\subsection{Iterate}

%%% iterate, int, string %%%

For all variants but \code{map} and \code{unordered_map}, iteration is
relatively similar, and much faster than \code{map}'s.

\subsection{Find}

\begin{tikzpicture}
    \begin{groupplot}[group style={group size=2 by 3, group name=myplot}, width=3.25in]


    \nextgroupplot[
        title={<int, int> Elements},
        xlabel=\empty,
        ylabel={Windows/MSVC 2015},
        xmin=0, xmax=32768,
        ymin=0, ymax=30.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.005113)(16,0.0102244)(32,0.0195558)(64,0.0386496)(128,0.0937254)(256,0.149963)(512,0.496689)(1024,0.599966)(2048,1.22234)(4096,2.88902)(8192,5.93183)(16384,9.98895)(32768,25.8163)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0052236)(16,0.0107272)(32,0.0194726)(64,0.0382162)(128,0.0757206)(256,0.147826)(512,0.309088)(1024,0.58985)(2048,1.19637)(4096,2.72328)(8192,5.56913)(16384,9.71472)(32768,24.1664)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.0048748)(16,0.0097772)(32,0.0195278)(64,0.0385112)(128,0.0756658)(256,0.15038)(512,0.296645)(1024,0.595536)(2048,1.3851)(4096,2.83163)(8192,5.74449)(16384,9.83455)(32768,24.4262)};
        \label{plots:plot2}

    \coordinate (top) at (rel axis cs:0,1);% coordinate at top of the first plot


    \nextgroupplot[
        title={<string, string> Elements},
        xlabel=\empty,
        ylabel=\empty,
        xmin=0, xmax=32768,
        ymin=0, ymax=60.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0,50.0,60.0,70.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0060762)(16,0.0123888)(32,0.025032)(64,0.052504)(128,0.109191)(256,0.227391)(512,0.487196)(1024,1.04212)(2048,2.18573)(4096,4.67721)(8192,9.95407)(16384,21.5232)(32768,46.9673)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.005783)(16,0.0122512)(32,0.024766)(64,0.0516398)(128,0.110279)(256,0.239066)(512,0.516182)(1024,1.11616)(2048,2.39217)(4096,5.29399)(8192,12.5597)(16384,27.0905)(32768,59.4786)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.005825)(16,0.0136178)(32,0.0247928)(64,0.0524512)(128,0.106253)(256,0.222168)(512,0.475994)(1024,1.0183)(2048,2.12132)(4096,4.55145)(8192,9.77859)(16384,20.9983)(32768,45.6506)};
        \label{plots:plot2}


    \nextgroupplot[
        title=\empty,
        xlabel=\empty,
        ylabel={Linux/Clang 3.8},
        xmin=0, xmax=32768,
        ymin=0, ymax=30.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.005113)(16,0.0102244)(32,0.0195558)(64,0.0386496)(128,0.0937254)(256,0.149963)(512,0.496689)(1024,0.599966)(2048,1.22234)(4096,2.88902)(8192,5.93183)(16384,9.98895)(32768,25.8163)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0052236)(16,0.0107272)(32,0.0194726)(64,0.0382162)(128,0.0757206)(256,0.147826)(512,0.309088)(1024,0.58985)(2048,1.19637)(4096,2.72328)(8192,5.56913)(16384,9.71472)(32768,24.1664)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.0048748)(16,0.0097772)(32,0.0195278)(64,0.0385112)(128,0.0756658)(256,0.15038)(512,0.296645)(1024,0.595536)(2048,1.3851)(4096,2.83163)(8192,5.74449)(16384,9.83455)(32768,24.4262)};
        \label{plots:plot2}


    \nextgroupplot[
        title=\empty,
        xlabel=\empty,
        ylabel=\empty,
        xmin=0, xmax=32768,
        ymin=0, ymax=60.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0,50.0,60.0,70.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0060762)(16,0.0123888)(32,0.025032)(64,0.052504)(128,0.109191)(256,0.227391)(512,0.487196)(1024,1.04212)(2048,2.18573)(4096,4.67721)(8192,9.95407)(16384,21.5232)(32768,46.9673)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.005783)(16,0.0122512)(32,0.024766)(64,0.0516398)(128,0.110279)(256,0.239066)(512,0.516182)(1024,1.11616)(2048,2.39217)(4096,5.29399)(8192,12.5597)(16384,27.0905)(32768,59.4786)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.005825)(16,0.0136178)(32,0.0247928)(64,0.0524512)(128,0.106253)(256,0.222168)(512,0.475994)(1024,1.0183)(2048,2.12132)(4096,4.55145)(8192,9.77859)(16384,20.9983)(32768,45.6506)};
        \label{plots:plot2}


    \nextgroupplot[
        title=\empty,
        xlabel={N},
        ylabel={Linux/GCC 4.8.4},
        xmin=0, xmax=32768,
        ymin=0, ymax=30.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.005113)(16,0.0102244)(32,0.0195558)(64,0.0386496)(128,0.0937254)(256,0.149963)(512,0.496689)(1024,0.599966)(2048,1.22234)(4096,2.88902)(8192,5.93183)(16384,9.98895)(32768,25.8163)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0052236)(16,0.0107272)(32,0.0194726)(64,0.0382162)(128,0.0757206)(256,0.147826)(512,0.309088)(1024,0.58985)(2048,1.19637)(4096,2.72328)(8192,5.56913)(16384,9.71472)(32768,24.1664)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.0048748)(16,0.0097772)(32,0.0195278)(64,0.0385112)(128,0.0756658)(256,0.15038)(512,0.296645)(1024,0.595536)(2048,1.3851)(4096,2.83163)(8192,5.74449)(16384,9.83455)(32768,24.4262)};
        \label{plots:plot2}


    \nextgroupplot[
        title=\empty,
        xlabel={N},
        ylabel=\empty,
        xmin=0, xmax=32768,
        ymin=0, ymax=60.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536},
        xticklabels={8,,,,,,,,2k,4k,8k,16k,32k,64k},
        ytick={0.0,10.0,20.0,30.0,40.0,50.0,60.0,70.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0060762)(16,0.0123888)(32,0.025032)(64,0.052504)(128,0.109191)(256,0.227391)(512,0.487196)(1024,1.04212)(2048,2.18573)(4096,4.67721)(8192,9.95407)(16384,21.5232)(32768,46.9673)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.005783)(16,0.0122512)(32,0.024766)(64,0.0516398)(128,0.110279)(256,0.239066)(512,0.516182)(1024,1.11616)(2048,2.39217)(4096,5.29399)(8192,12.5597)(16384,27.0905)(32768,59.4786)};
        \label{plots:plot1}

    \addplot[color=green,mark=|,no markers,]
        coordinates {(8,0.005825)(16,0.0136178)(32,0.0247928)(64,0.0524512)(128,0.106253)(256,0.222168)(512,0.475994)(1024,1.0183)(2048,2.12132)(4096,4.55145)(8192,9.77859)(16384,20.9983)(32768,45.6506)};
        \label{plots:plot2}

    \coordinate (bot) at (rel axis cs:1,0);% coordinate at bottom of the last plot

    \end{groupplot}

    \path (myplot c1r1.outer north west)% plot in column 1 row 1
          -- node[anchor=south,rotate=90] {Time [milliseconds]}% label midway
          (myplot c1r3.outer south west);% plot in column 1 row 3

    % legend
    \path (myplot c1r3.south west|-current bounding box.south)--
      coordinate(legendpos)
      (myplot c2r3.south east|-current bounding box.south);
    \matrix[
        matrix of nodes,
        anchor=south,
        draw,
        inner sep=0.2em,
        draw
      ]at([yshift=-5ex]legendpos)
      {
        \ref{plots:plot0}& Boost.FlatMap&[5pt]
        \ref{plots:plot1}& std::map&[5pt]
        \ref{plots:plot2}& split\_map\_t&[5pt]\\
      };

\end{tikzpicture}
\\
\\


\code{find()} performance is where things get interesting.  The different
platforms produce strikingly different results.\\

In the MSVC runs, there is a large differentiation between Boost.FlatMap and
\code{map}; in fact, Boost.FlatMap even beats both the sorted \code{vector}
variants.  Also, \code{unordered_map} is the clear winner, regardless of
valkue type.\\

GCC and Clang on Linux produce nearly identical results.  For \code{<int,
  int>} runs, all implementations are nearly identical.  \code{unordered_map}
is faster in the \code{<std::string, std::string>} runs, but all other
variants are very close.

\subsection{Erase}

%%% erase, int, string %%%

Erasure has a nearly identical performance profile to insertion.\\


\subsection{Implications}

Iteration is vastly cheaper for contiguous-storage variants.  Any node-based
associative container will always be slower than a flattened one for
iteration.  For use cases where there is a lot of iteration, this can be the
deciding runtime performance consideration.\\

In all the graphs above, the reason the custom-\code{pair} sorted vector
performs so much better than \code{vector<pair<int, int>>} seems to be that
the custom-\code{pair} type has \code{nothrow} special functions.
Implementing all the special functions and adding \code{nothrow(false)} to
each makes the custom-\code{pair} version perform identically to the
\code{pair<int, int>} version.\\

Boost.FlatMap differs significantly from a sorted \code{vector}.  Clearly
there are a lot of QOI choices that affect the runtime performance of a
standard \code{flat_map}.\\

The fact that insertion and erasure operations produce such similar results
implies that pre-\code{reserve()}ing space will probably not make much
difference when using a flat map.\\

Use cases in which the runtime performance of a flat map would be no better
than \code{map} or \code{unordered_map}, the user may still decide to use a
flat implementation for the storage savings.
