\section{Motivation and Scope}

There has been a strong desire for a more space- and/or runtime-efficient
representation for \code{map} among C++ users for some time now.  This has
motivated discussions among the members of SG14 resulting in a
paper\footnote{See P0038R0,
  \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0038r0.html}{here}.},
numerous articles and talks, and an implementation in Boost,
\code{boost::container::flat_map}\footnote{Part of Boost.Container,
  \href{http://www.boost.org/doc/libs/1_61_0/doc/html/container.html}{here}.}.
Virtually everyone who makes games, embedded, or system software in C++ uses
the Boost implementation or one that they rolled themselves.\\

Here are some numbers that show why.  The graphs that follow show runtimes for
different \code{map}-like associative containers.  The containers used are
Boost.FlatMap, \code{map}, \code{unordered_map}, and two thin wrappers over a
sorted \code{vector}.  The ``custom pair'' version of the sorted \code{vector}
uses a simple \code{struct} instead of \code{pair} for its value type.  All
containers use either \code{<int, int>} or \code{<std::string, std::string>}
for the value type.\\

All data in the graphs below were produced on Windows with MSVC 2015, on Linux
with Clang 3.8 and libc++, or on Linux with g++ 4.8.4 and libstdc++.\\

Each set of six graphs shows the performance of a single operation on all
map-variants.  The left column shows the \code{<int, int>} runs, and the right
column shows the \code{<std::string, std::string>} ones.  Each row shows one
platform/compiler configuration. \\

These four sets of graphs cover the most commonly-used operations.  The first
set shows insertion of N elements with random keys; the second shows full
iteration across all N elements; the third shows \code{map.find()} called once
for each key used in the original insertions; and the fourth shows erasure of
all N elements, by the keys used in the original insertions.\\

\subsection{Insert}

%%% insert, int, string %%%

Unsurprisingly, insertion takes longer in contiguous-storage implementations.
Boost.FlatMap and a sorted \code{vector<pair<int, int>>} have the steepest
growth curves.  The curve for sorted \code{vector} using a custom
\code{struct} is dramatically flatter in its growth in the \code{<int, int>}
runs.  Note that the custom-pair vector does about the same as the
\code{vector} of \code{pair} in the \code{<std::string, std::string>} runs.

\subsection{Iterate}

%%% iterate, int, string %%%

For all variants but \code{map} and \code{unordered_map}, iteration is
relatively similar, and much faster than \code{map}'s.

\subsection{Find}

\begin{tikzpicture}
    \begin{groupplot}[group style={group size=2 by 3, group name=myplot}, width=3.25in]


    \nextgroupplot[
        title={<int, int> Elements},
        xlabel=\empty,
        ylabel={Windows/MSVC 2015},
        xmin=0, xmax=262144,
        ymin=0, ymax=100.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,10.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0,100.0,110.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0005412)(16,0.0008412)(32,0.002224)(64,0.0054688)(128,0.0102168)(256,0.0222946)(512,0.0460896)(1024,0.096454)(2048,0.197886)(4096,0.416388)(8192,0.902735)(16384,1.97101)(32768,4.70278)(65536,10.7202)(131072,26.1432)(262144,58.1358)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.000481)(16,0.0010814)(32,0.0022836)(64,0.004326)(128,0.008954)(256,0.0337118)(512,0.0424848)(1024,0.0918238)(2048,0.207265)(4096,0.477749)(8192,1.30968)(16384,2.72267)(32768,6.00409)(65536,13.9543)(131072,34.5729)(262144,90.7993)};
        \label{plots:plot1}

    \coordinate (top) at (rel axis cs:0,1);% coordinate at top of the first plot


    \nextgroupplot[
        title={<string, string> Elements},
        xlabel=\empty,
        ylabel=\empty,
        xmin=0, xmax=262144,
        ymin=0, ymax=200.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,100.0,200.0,300.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0003604)(16,0.002043)(32,0.0031842)(64,0.00667)(128,0.0124398)(256,0.028905)(512,0.0628)(1024,0.145728)(2048,0.327452)(4096,0.734536)(8192,1.75895)(16384,3.92775)(32768,8.87618)(65536,19.5561)(131072,46.4218)(262144,97.8965)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0010814)(16,0.001924)(32,0.0029446)(64,0.0087738)(128,0.0115978)(256,0.0273422)(512,0.0612924)(1024,0.23881)(2048,0.310203)(4096,0.66801)(8192,1.75709)(16384,3.98783)(32768,9.15727)(65536,20.7585)(131072,54.7061)(262144,126.507)};
        \label{plots:plot1}


    \nextgroupplot[
        title=\empty,
        xlabel=\empty,
        ylabel={Linux/Clang 3.8},
        xmin=0, xmax=262144,
        ymin=0, ymax=200.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,100.0,200.0,300.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0054198)(16,0.0100988)(32,0.0201558)(64,0.0406194)(128,0.076604)(256,0.149936)(512,0.296993)(1024,0.596073)(2048,1.19227)(4096,2.38213)(8192,4.73735)(16384,9.4979)(32768,18.9977)(65536,38.4231)(131072,92.1881)(262144,190.663)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0052942)(16,0.010323)(32,0.0199332)(64,0.0373932)(128,0.075818)(256,0.149026)(512,0.294076)(1024,0.584615)(2048,1.18726)(4096,2.35996)(8192,4.69498)(16384,9.43802)(32768,18.9069)(65536,37.8061)(131072,89.4446)(262144,186.509)};
        \label{plots:plot1}


    \nextgroupplot[
        title=\empty,
        xlabel=\empty,
        ylabel=\empty,
        xmin=0, xmax=262144,
        ymin=0, ymax=500.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,100.0,200.0,300.0,400.0,500.0,600.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.00623)(16,0.012502)(32,0.0257304)(64,0.0531642)(128,0.107652)(256,0.22447)(512,0.486909)(1024,1.04667)(2048,2.19239)(4096,4.6285)(8192,9.97828)(16384,21.6678)(32768,47.051)(65536,99.4976)(131072,207.773)(262144,432.105)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0060206)(16,0.0118598)(32,0.0240532)(64,0.049644)(128,0.106493)(256,0.222082)(512,0.466196)(1024,0.995564)(2048,2.0714)(4096,4.45539)(8192,9.70291)(16384,21.2232)(32768,46.299)(65536,99.608)(131072,219.095)(262144,487.447)};
        \label{plots:plot1}


    \nextgroupplot[
        title=\empty,
        xlabel={N},
        ylabel={Linux/GCC 4.8.4},
        xmin=0, xmax=262144,
        ymin=0, ymax=200.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,100.0,200.0,300.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.0048888)(16,0.0100706)(32,0.0194854)(64,0.0390972)(128,0.072914)(256,0.146318)(512,0.299227)(1024,0.584032)(2048,1.19186)(4096,2.37731)(8192,4.7119)(16384,9.41508)(32768,18.861)(65536,38.3751)(131072,76.9515)(262144,154.878)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.0053782)(16,0.0107126)(32,0.0201982)(64,0.0422534)(128,0.0891904)(256,0.160524)(512,0.310125)(1024,0.609725)(2048,1.21073)(4096,2.41461)(8192,4.73932)(16384,9.50771)(32768,19.1076)};
        \label{plots:plot1}


    \nextgroupplot[
        title=\empty,
        xlabel={N},
        ylabel=\empty,
        xmin=0, xmax=262144,
        ymin=0, ymax=400.0,
        xtick={8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288},
        xticklabels={8,,,,,,,,,,,,32k,64k,128k,256k,512k},
        ytick={0.0,100.0,200.0,300.0,400.0,500.0},
        ymajorgrids=true,
        grid style=dashed,
        scaled x ticks=false,
        scaled y ticks=true,
        ]

    \addplot[color=blue,mark=|,no markers,]
        coordinates {(8,0.004819)(16,0.0100296)(32,0.020211)(64,0.039191)(128,0.0822048)(256,0.163804)(512,0.341695)(1024,0.709312)(2048,1.46743)(4096,3.05207)(8192,6.53024)(16384,13.4751)(32768,30.6919)(65536,65.1518)(131072,139.465)(262144,304.352)};
        \label{plots:plot0}

    \addplot[color=red,mark=|,no markers,]
        coordinates {(8,0.005755)(16,0.0117196)(32,0.0234376)(64,0.0478842)(128,0.103574)(256,0.207958)(512,0.484611)(1024,1.07287)(2048,2.17595)(4096,4.02796)(8192,10.1699)(16384,22.7216)(32768,47.7152)};
        \label{plots:plot1}

    \coordinate (bot) at (rel axis cs:1,0);% coordinate at bottom of the last plot

    \end{groupplot}

    \path (myplot c1r1.outer north west)% plot in column 1 row 1
          -- node[anchor=south,rotate=90] {Time [milliseconds]}% label midway
          (myplot c1r3.outer south west);% plot in column 1 row 3

    % legend
    \path (myplot c1r3.south west|-current bounding box.south)--
      coordinate(legendpos)
      (myplot c2r3.south east|-current bounding box.south);
    \matrix[
        matrix of nodes,
        anchor=south,
        draw,
        inner sep=0.2em,
        draw
      ]at([yshift=-5ex]legendpos)
      {
        \ref{plots:plot0}& Boost.FlatMap&[5pt]
        \ref{plots:plot1}& std::map&[5pt]\\
      };

\end{tikzpicture}
\\
\\


\code{find()} performance is where things get interesting.  The different
platforms produce strikingly different results.\\

In the MSVC runs, there is a large differentiation between Boost.FlatMap and
\code{map}; in fact, Boost.FlatMap even beats both the sorted \code{vector}
variants.  Also, \code{unordered_map} is the clear winner, regardless of
valkue type.\\

GCC and Clang on Linux produce nearly identical results.  For \code{<int,
  int>} runs, all implementations are nearly identical.  \code{unordered_map}
is faster in the \code{<std::string, std::string>} runs, but all other
variants are very close.

\subsection{Erase}

%%% erase, int, string %%%

Erasure has a nearly identical performance profile to insertion.\\


\subsection{Implications}

Iteration is vastly cheaper for contiguous-storage variants.  Any node-based
associative container will always be slower than a flattened one for
iteration.  For use cases where there is a lot of iteration, this can be the
deciding runtime performance consideration.\\

In all the graphs above, the reason the custom-\code{pair} sorted vector
performs so much better than \code{vector<pair<int, int>>} seems to be that
the custom-\code{pair} type has \code{nothrow} special functions.
Implementing all the special functions and adding \code{nothrow(false)} to
each makes the custom-\code{pair} version perform identically to the
\code{pair<int, int>} version.\\

Boost.FlatMap differs significantly from a sorted \code{vector}.  Clearly
there are a lot of QOI choices that affect the runtime performance of a
standard \code{flat_map}.\\

The fact that insertion and erasure operations produce such similar results
implies that pre-\code{reserve()}ing space will probably not make much
difference when using a flat map.\\

Use cases in which the runtime performance of a flat map would be no better
than \code{map} or \code{unordered_map}, the user may still decide to use a
flat implementation for the storage savings.
