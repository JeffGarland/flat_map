\section{Proposed Design}

\subsection{Design Goals}

Overall, \code{flat_map} is meant to be a drop-in replacement for \code{map},
just with different time- and space-efficiency properties.  Functionally it is
not meant to do anything other than what we do with \code{map} now.\\

The Boost.Container documentation gives a nice summary of the tradeoffs
between node-based and flat associative containers (quoted here, mostly
verbatim).  Note that they are not purely positive:

\begin{itemize}
  \item Faster lookup than standard associative containers.

  \item Much faster iteration than standard associative
    containers.

  \item Random-access iterators instead of bidirectional iterators.

  \item Less memory consumption for each element.

  \item Improved cache performance (data is stored in contiguous memory).

  \item Non-stable iterators (iterators are invalidated when inserting and
    erasing elements).

  \item Non-copyable and non-movable values types can't be stored.

  \item Weaker exception safety than standard associative containers
    (copy/move constructors can throw when shifting values in erasures and
    insertions).

  \item Slower insertion and erasure than standard associative containers
    (specially for non-movable types).
\end{itemize}

The overarching goal of this proposal is to define a \code{flat_map} for
standardization that fits the above gross profile, while leaving maximum room
for customization by users.

\subsection{Design}

\subsubsection{\code{flat_map} Is Based Primarily On Boost.FlatMap}

This proposal represents existing practice in widespread use -- Boost.FlatMap
has been available since 2011 (Boost 1.48).  As of Boost 1.65, the Boost
implementation will optionally act as an adapter.

\subsubsection{\code{flat_map} Is Nearly API-Compatible With \code{map}}

Most of \code{flat_map}'s interface is identical to \code{map}'s.  Some of the
differences are required (more on this later), but a couple of interface
changes are optional:

\begin{itemize}
  \item The overloads that take sorted containers or iterator pairs.

  \item Making \code{flat_map} a container adapter.
\end{itemize}

Both of these interface changes were added to increase optimization
opportunities.

\subsubsection{\code{flat_map} Is a Container Adapter That Uses Proxy Iterators}

\code{flat_map} is an adapter for two underlying storage types.  These storage
types are configurable via the template parameters \code{KeyContainer} and
\code{MappedContainer}.  Each must be a \textit{sequence container} with
random access iterator (\S26.2.3).\\

The previous revision of this paper suggested such a split storage scheme as a
possibility for future work, but this is now the proposed approach for all
flat maps.\\

This change was made for several reasons.\\

First, LEWG was strongly against a flat map \code{value_type} with a
non-\code{const} key.  LEWG was also strongly against presenting values from
the underlying storage container (which must have non-\code{const} keys) as if
they were key-\code{const}.  It was feared that this would not be
implementable without relying on undefined or implementation-defined behavior.
Because of this, both \code{iterator} and \code{const_iterator} must be proxy
iterators.  Note that this implies that this proposal depends on the Ranges TS.\\

Second, there are dramatic performance gains to \code{insert()} and
\code{erase()} when using split storage for small key and value types.  There
do not appear to be any performance losses from using the split storage scheme.\\

Third, having separate \code{flat_map} and \code{split_flat_map} would be
possible, but it would be very easy to use the less-optimal one, especially
under maintenance.  Consider the case in which a \code{flat_map<std::string,
  int>} is changed to \code{flat_map<int, int>} once hashing is introduced on
the keys.  The user would then have to remember that a change to
\code{split_flat_map} would be more optimal -- a chancy proposition.

\subsubsection{Interface Differences From \code{map}}

\begin{itemize}
  \item Several new constructors have been added that take objects of the
    \code{KeyContainer} and \code{MappedContainer} types.

  \item The \code{extract()} overloads from \code{map} are replaced with a
    version that produces the underlying storage containers, moving out the
    entire storage of the \code{flat_map}.  Similarly, the \code{insert()}
    members taking a node have been replaced with a member \code{void
      replace(KeyContainer&&, MappedContainer&&)}, that moves in the entire
    storage.

    Many users have noted that M insertions of elements into a map of size N
    is O(M$\cdot$log(N+M)), and when M is known it should be possible instead
    to append M times, and then re-sort, as one might with a sorted
    \code{vector}.  This makes the insertion of multiple elements closer to
    O(N), depending on the implementation of \code{sort()}.

    Such users have often asked for an API in
    \code{boost::container::flat_map} that allows this pattern of use.  Other
    flat-map implementations have undoubtedly added such an API.  The
    extract/replace API instead allows the same optimization opportunities
    without violating the class invariants.

  \item Several new constructors and an \code{insert()} overload use a new tag
    type, \code{sorted_unique_t}.  These members must only be used if the
    given values are already sorted.  This can allow much more efficient
    construction and insertion.
\end{itemize}

\subsubsection{\code{flat_map} Requirements}

Since the elements of the underlying container may be moved or copied during
inserts and erases, the element type of \code{KeyContainer} must be
\code{Key}, and \code{MappedContainer}'s element type must be not \code{T}.
This requires \code{flat_map} to have an iterator that adapts the underlying
container iterators.

Only the underlying containers are allocator-aware.  \S26.2.4/7 regarding
allocator awareness does not apply to \code{flat_map}.

Validity of iterators is not preserved when mutating the underlying container
(i.e. \S26.2.4/9 does not apply).

The exception safety guarantees for associative containers (\S26.2.4.1) do not
apply.

The rest of the requirements follow the ones in (\S26.2.4 Associative
containers), except \S26.2.4/10 (which applies to members not in
\code{flat_map}) and some portions of the table in \S26.2.4/8; these table
differences are outlined in ``Member Semantics'' below.

\subsubsection{Container Requirements}

Any sequence container with random access iterator can be used for the
container template parameters.

\subsubsection{Member Semantics}

Each member taking a container reference or taking a parameter of type
\code{sorted_unique_t} has the precondition that the given
elements are already sorted by \code{Compare}, and that the elements are
unique.

Each member taking a allocator template parameters only participates in
overload resolution if \code{uses_allocator_v<KeyContainer, KeyAlloc>} and
\code{uses_allocator_v<MappedContainer, MappedAlloc>} are both \code{true}.

Other member semantics are the same as for \code{map}.

\subsubsection{\code{flat_map} Synopsis}

\lstinputlisting[language=C++]{map_synopsis.hpp}


\section{Acknowledgements}

Thanks to Ion Gazta\~{n}aga for writing Boost.FlatMap.\\

Thanks to Sean Middleditch for suggesting the use of split containers for keys
and values.
