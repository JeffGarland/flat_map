\section{Proposed Design}

\subsection{Design Goals}

Overall, \code{flat_set} is meant to be a drop-in replacement for \code{set},
just with different time- and space-efficiency properties.  Functionally it is
not meant to do anything other than what we do with \code{set} now.\\

Note that this paper proposes a \code{flat_multiset} as well, which hs the
same relationship to \code{flat_set} that \code{multiset} has to \code{set}.
That is, duplicate elements are allowed in a \code{flat_multiset}.  The pair
of \code{flat_set} and \code{flat_multiset} will be referred to herafter
simply as ``\code{flat_set}'' for brevity.\\

The Boost.Container documentation gives a nice summary of the tradeoffs
between node-based and flat associative containers (quoted here, mostly
verbatim).  Note that they are not purely positive:

\begin{itemize}
  \item Faster lookup than standard associative containers.

  \item Much faster iteration than standard associative
    containers.

  \item Random-access iterators instead of bidirectional iterators.

  \item Less memory consumption for each element.

  \item Improved cache performance (data is stored in contiguous memory).

  \item Non-stable iterators (iterators are invalidated when inserting and
    erasing elements).

  \item Non-copyable and non-movable values types can't be stored.

  \item Weaker exception safety than standard associative containers
    (copy/move constructors can throw when shifting values in erasures and
    insertions).

  \item Slower insertion and erasure than standard associative containers
    (specially for non-movable types).
\end{itemize}

The overarching goal of this proposal is to define a \code{flat_set} for
standardization that fits the above gross profile, while leaving maximum room
for customization by users.

\subsection{Design}

\subsubsection{\code{flat_set} Is Based Primarily On Boost.FlatSet}

This proposal represents existing practice in widespread use --
Boost.Container's \code{flat_set} has been available since 2011 (Boost 1.48).
As of Boost 1.65, the Boost implementation will optionally act as an adapter.

\subsubsection{\code{flat_set} Is Nearly API-Compatible With \code{set}}

Most of \code{flat_set}'s interface is identical to \code{set}'s.  Some of the
differences are required (more on this later), but a couple of interface
changes are optional:

\begin{itemize}
  \item The overloads that take sorted containers or iterator pairs.

  \item Making \code{flat_set} a container adapter.
\end{itemize}

Both of these interface changes were added to increase optimization
opportunities.

\subsubsection{\code{flat_set} Is a Container Adapter That Uses Proxy Iterators}

\code{flat_set} is an adapter for an underlying storage type.  This storage
type is configurable via the template parameter \code{Container}, which must
be a \textit{sequence container} with random access iterator (\S26.2.3).\\

\subsubsection{Interface Differences From \code{set}}

\begin{itemize}
  \item Several new constructors have been added that take an object of the
    \code{Container} type.

  \item The \code{extract()} overloads from \code{set} are replaced with a
    version that produces the underlying storage container, moving out the
    entire storage of the \code{flat_set}.  Similarly, the \code{insert()}
    members taking a node have been replaced with a member \code{void
      replace(Container&&)}, that moves in the entire storage.

    Many users have noted that M insertions of elements into a set of size N
    is O(M$\cdot$log(N+M)), and when M is known it should be possible instead
    to append M times, and then re-sort, as one might with a sorted
    \code{vector}.  This makes the insertion of multiple elements closer to
    O(N), depending on the implementation of \code{sort()}.

    Such users have often asked for an API in
    \code{boost::container::flat_set} that allows this pattern of use.  Other
    flat-set implementations have undoubtedly added such an API.  The
    extract/replace API instead allows the same optimization opportunities
    without violating the class invariants.

  \item Several new constructors and an \code{insert()} overload use a new tag
    type, \code{sorted_unique_t} (\code{flat_multiset} uses a special tag type
    \code{sorted_t}).  These members expect that the given values are already
    in sorted oreder.  This can allow much more efficient construction and
    insertion.
\end{itemize}

\subsubsection{\code{flat_set} Requirements}

Only the underlying container is allocator-aware.  \S26.2.4/7 regarding
allocator awareness does not apply to \code{flat_set}.

Validity of iterators is not preserved when mutating the underlying container
(i.e. \S26.2.4/9 does not apply).

The exception safety guarantees for associative containers (\S26.2.4.1) do not
apply.

The rest of the requirements follow the ones in (\S26.2.4 Associative
containers), except \S26.2.4/10 (which applies to members not in
\code{flat_set}) and some portions of the table in \S26.2.4/8; these table
differences are outlined in ``Member Semantics'' below.

\subsubsection{Container Requirements}

Any sequence container with random access iterator can be used for the
container template parameters.

\subsubsection{Member Semantics}

Each member taking a container reference or taking a parameter of type
\code{sorted_unique_t} (\code{sorted_t} for \code{flat_multimap}) has the
precondition that the given elements are already sorted by \code{Compare}, and
that the elements are unique.

Each member taking an allocator template parameter only participates in
overload resolution if \code{uses_allocator_v<Container, Alloc>} is
\code{true}.

Other member semantics are the same as for \code{set}.

\subsubsection{\code{flat_set} Synopsis}

\lstinputlisting[language=C++]{set_synopsis.hpp}


\section{Acknowledgements}

Thanks to Ion Gazta\~{n}aga for writing Boost.FlatSet.
