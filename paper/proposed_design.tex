\section{Proposed Design}

\subsection{Design Goals}

Overall, \code{flat_map} is meant to be a drop-in replacement for \code{map},
just with different time- and space-efficiency properties.  Functionally it is
not meant to do anything other than what we do with \code{map} now.\\

The Boost.Container documentation gives a nice summary of the tradeoffs
between node-based and flat associative containers (quoted here, mostly
verbatim).  Note that they are not purely positive:

\begin{itemize}
  \item Faster lookup than standard associative containers.

  \item Much faster iteration than standard associative
    containers.

  \item Random-access iterators instead of bidirectional iterators.

  \item Less memory consumption for each element.

  \item Improved cache performance (data is stored in contiguous memory).

  \item Non-stable iterators (iterators are invalidated when inserting and
    erasing elements).

  \item Non-copyable and non-movable values types can't be stored.

  \item Weaker exception safety than standard associative containers
    (copy/move constructors can throw when shifting values in erasures and
    insertions).

  \item Slower insertion and erasure than standard associative containers
    (specially for non-movable types).
\end{itemize}

The overarching goal of this proposal is to define a \code{flat_map} for
standardization that fits the above gross profile, while leaving maximum room
for customization by users.

\subsection{Design}

\subsubsection{\code{flat_map} Is Based On Boost.FlatMap}

This proposal represents existing practice in widespread use -- Boost.FlatMap
has been available since 2011 (Boost 1.48).

\subsubsection{\code{flat_map} Is Nearly API-Compatible With \code{map}}

Most of \code{flat_map}'s interface is identical to \code{map}'s.  Some of the
differences are required (more on this later), but a couple of interface
changes are optional:

\begin{itemize}
  \item The overloads that take sorted containers or sequences.

  \item Making \code{flat_map} a container adapter.
\end{itemize}

Both of these interface changes were added to increase optimization
opportunities.

\subsubsection{\code{flat_map} Is a Container Adapter}

\code{flat_map} is an adapter for an underlying storage type.  This storage
type is configurable via the template parameter \code{Container}.
\code{Container} must be a \textit{sequence container} (\S23.2.3).
\code{vector} is a great candidate for this, but limiting \code{flat_map} only
to use \code{vector} for its storage would be a mistake.  Many other suitable
replacements exist, each suited to a certain use.  A user may have a
small-buffer implementation of \code{vector}, like LLVM's \code{SmallVector},
or \code{boost::container::small_vector}.  The user may also want to avoid
allocations altogether, if the maximum number of elements N is known \textit{a
  priori}.  If so, \code{boost::container::static_vector} could be used.  The
user's specific performance requirements will dictate which of these is most
appropriate.\\

There are certain optimization opportunities that are lost to the user of a
non-adapter \code{flat_map}.  For instance, if one does not care about the
strong or weak exception guarantees in the code that uses \code{flat_map}, one
can use a \code{Container} that blindly uses \code{move} all the time, even if
exceptions may occur.\\

While this may not be a use case for a majority of users, there are numerous
such niche use cases, and these niches are not well served by a fixed
underlying storage implementation.

\subsubsection{Interface Differences From \code{map}}

\begin{itemize}
  \item Several new constructors have been added that take objects of the
    \code{Container} type.  These members must only be used if the given
    container is already sorted.

  \item The \code{extract()} overloads from \code{map} are replaced with
    \code{Container extract()}, that moves out the entire storage of the
    \code{flat_map}.  Similarly, the \code{insert()} members taking a node
    have been replaced with a member \code{void replace(Container&&)}, that
    moves in the entire storage.

    Many users have noted that M insertions of elements into a map of size N
    is O(M$\cdot$log(N+M)), and when M is known it should be possible instead
    to append M times, and then re-sort, as one might with a sorted
    \code{vector}.  This makes the insertion of multiple elements closer to
    O(N), depending on the implementation of \code{sort()}.

    Such users have often asked for an API in
    \code{boost::container::flat_map} that allows this pattern of use.  Other
    flat-map implementations have undoubtedly added such an API.  The
    extract/replace API instead allows the same optimization opportunities
    without violating the class invariants.

  \item Several new constructors and an \code{insert()} overload use a new tag
    type, \code{ordered_unique_sequence_tag}.  These members must only be used
    if the given sequence is already sorted.  This can allow much more
    efficient construction and insertion.
\end{itemize}

\subsubsection{\code{flat_map} Requirements}

Since the elements of the underlying container may be moved or copied during
inserts and erases, the element type of \code{Container} must be
\code{pair<Key, T>}, not \code{pair<const Key, T>}.  Even so, the element type
of \code{flat_map} should still be \code{pair<const Key, T>}, for drop-in
compatibility with \code{map} (\S23.2.4/5).  This requires \code{flat_map} to
have an iterator that adapts the underlying \code{Container} iterator.

Only the underlying container is allocator-aware.  \S23.2.4/7 regarding
allocator awareness does not apply to \code{flat_map}.

Validity of iterators is not preserved when mutating the underlying container
(i.e. \S23.2.4/9 does not apply).

The exception safety guarantees for associative containers (\S23.2.4.1) do not
apply.

The rest of the requirements follow the ones in (\S23.2.4 Associative
containers), except \S23.2.4/10 (which applies to members not in
\code{flat_map}) and some portions of the table in \S23.2.4/8; these table
differences are outlined in ``Member Semantics'' below.

\subsubsection{\code{Container} Requirements}

Any sequence container with random access iterator can be used for the
\code{Container} template parameter.  \code{Container} must have a
\code{value_type} of \code{pair<Key, T>}.

TODO: Can this be relaxed, using structured bindings to take the underlying
sequence's value type and use it to form the
\code{pair<key_type const &, mapped_type &>} proxy?

\subsubsection{Member Semantics}

Each member taking a \code{Container} reference or taking a parameter of type
\code{ordered_unique_sequence_tag} has the precondition that the given
elements are already sorted by \code{Compare}, and that the elements are
unique.

Each member taking an \code{Alloc} template parameter only participates in
overload resolution if \code{uses_allocator_v<Container, Alloc>} is
\code{true}.

Other member semantics are the same as for \code{map}.

\subsubsection{\code{flat_map} Synopsis}

\lstinputlisting[language=C++]{map_synopsis.hpp}


\section{Future Work}

Though splitting the key and value storage in a flat map has significant
insertion performance benefits for small types, I've not proposed a
\code{split_flat_map} type here.  This would definitely be a useful type to
standardize, but its iterator would be a proxy iterator, something for which
we as a community have not yet settled on a best practice.


\section{Acknowledgements}

Thanks to Ion Gazta\~{n}aga for writing Boost.FlatMap.\\

Thanks to David Sankel, for reviews of early drafts of this paper.\\

Thanks to Bloomberg, for sharing performance data they used for internal
decisionmaking on their use of flat maps.\\

Thanks to Sean Middleditch for suggesting the use of split containers for keys
and values, and for suggestions on improving the benchmarking code.
