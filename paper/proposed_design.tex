\section{Proposed Design}

\subsection{Design Goals}

The Boost.Container documentation gives a nice summary of the tradeoffs
between node-based and flat associative containers (quoted here, mostly
verbatim).  Note that they are not purely positive:

\begin{itemize}
  \item Faster lookup than standard associative containers.

  \item Much faster iteration than standard associative
    containers.

  \item Random-access iterators instead of bidirectional iterators.

  \item Less memory consumption for each element.

  \item Improved cache performance (data is stored in contiguous memory).

  \item Non-stable iterators (iterators are invalidated when inserting and
    erasing elements).

  \item Non-copyable and non-movable values types can't be stored.

  \item Weaker exception safety than standard associative containers
    (copy/move constructors can throw when shifting values in erasures and
    insertions).

  \item Slower insertion and erasure than standard associative containers
    (specially for non-movable types).
\end{itemize}

The overarching goal of this proposal is to define a \code{flat_map} for
standardization that fits the above gross profile, while leaving maximum room
for customization by users.

\subsection{Design}

\subsubsection{\code{flat_map} Is a Container Adapter}

\code{flat_map} is an adapter for an underlying storage type.  This storage
type is configurable via the template parameter \code{Container}.
\code{Container} must be a \textit{contiguous container} (\S23.2.1/13).
\code{vector} is a great candidate for this, but limiting \code{flat_map} only
to use \code{vector} for its storage would be a mistake.  Many other suitable
replacements exist, each suited to a certain use.  A user may have a
small-buffer implementation of \code{vector}, like LLVM's \code{SmallVector},
or \code{boost::container::small_vector}.  The user may also want to avoid
allocations altogether, if the maximum number of elements N is know \textit{a
  priori}.  If so, \code{boost::container::static_vector} could be used.

\subsubsection{Interface Differences From \code{map}}

\begin{itemize}
  \item Members \code{capacity()}, \code{reserve()}, and \code{shrik_to_fit()}
    have been added, with the same semantics as the corresponding members of
    \code{vector}.

  \item Several new constructors have been added that take objects of the
    \code{Container} type.  These members must only be used if the given
    container is already sorted.

  \item The \code{extract()} overloads from \code{map} are replaced with
    \code{Container extract()}, that moves out the entire storage of the
    \code{flat_map}.  Similarly, the \code{insert()} members taking a node
    have been replaced with a member \code{void replace(Container&&)}, that
    moves in the entire storage.

    Many users have noted that M insertions of elements into a map of size N
    is O(M$\cdot$log(N+M)), and when M is known it should be possible instead
    to append M times, and then re-sort, as one might with a sorted
    \code{vector}.  This makes the insertion of multiple elements closer to
    O(N), depending on the implementation of \code{sort()}.

    Such users have often asked for an API in
    \code{boost::container::flat_map} that allows this pattern of use.  Other
    flat-map implementations have undoubtedly added such an API.  The
    extract/replace API instead allows the same optimization opportunities
    without violating the class invariants.

  \item Several new constructors and an \code{insert()} overload use a new tag
    type, \code{ordered_unique_sequence_tag}.  These members must only be used
    if the given sequence is already sorted.  This can allow much more
    efficient construction and insertion.
\end{itemize}

\subsubsection{\code{flat_map} Requirements}

(TODO! Change the synopsis to reflect this!) Since the underlying container is
contiguous and elements may be moved or copied during inserts and erases, the
element type of \code{Container} must be \code{pair<Key, T>}, not
\code{pair<const Key, T>}.  Even so, the element type of \code{flat_map}
should still be \code{pair<const Key, T>}, for drop-in compatibility with
\code{map} (\S23.2.4/5).

Only the underlying container is allocator-aware.  \S23.2.4/7 regarding
allocator awareness does not apply to \code{flat_map}.

Validity of iterators is not preserved when mutating the underlying container
(i.e. \S23.2.4/9 does not apply).

The exception safety guarantees for associative containers (\S23.2.4.1) do not
apply.

The rest of the requirements follow the ones in (\S23.2.4 Associative
containers), except \S23.2.4/10, which applies to members not in
\code{flat_map} and select portions of the table in \S23.2.4/8.  These table
differences are outlined in ``Member Semantics'' below.

\subsubsection{\code{Container} Requirements}

Any contiguous container supporting operations \code{capacity()},
\code{reserve()}, and \code{shrik_to_fit()} can be used for the
\code{Container} template parameter.  \code{Container} must have a
\code{value_type} of \code{pair<Key, T>}.

\subsubsection{Member Semantics}

Members \code{capacity()}, \code{reserve()}, and \code{shrik_to_fit()} have
the same semantics as the corresponding members of \code{vector}.

Each member taking a \code{Container} reference or taking a parameter of type
\code{ordered_unique_sequence_tag} has the precondition that the given
elements are already sorted by \code{Compare}, and that the elements are
unique.

Each member taking an \code{Alloc} template parameter only participates in
overload resolution if \code{uses_allocator_v<Container, Alloc>} is
\code{true}.

Other member semantics are the same as for \code{map}.

\subsubsection{\code{flat_map} Synopsis}

\lstinputlisting[language=C++]{map_synopsis.hpp}
