%!TEX root = std.tex
\setcounter{chapter}{15}
\setcounter{section}{5}
\setcounter{subsection}{1}
\setcounter{subsubsection}{1}

\rSec3[headers]{Headers}

\begin{multicolfloattable}{\Cpp{} library headers}{tab:cpp.library.headers}
{llll}
\tcode{<algorithm>} \\
\tcode{<any>} \\
\tcode{<array>} \\
\tcode{<atomic>} \\
\tcode{<bit>} \\
\tcode{<bitset>} \\
\tcode{<charconv>} \\
\tcode{<chrono>} \\
\tcode{<codecvt>} \\
\tcode{<compare>} \\
\tcode{<complex>} \\
\tcode{<concepts>} \\
\tcode{<condition_variable>} \\
\tcode{<contract>} \\
\tcode{<deque>} \\
\tcode{<exception>} \\
\tcode{<execution>} \\
\tcode{<filesystem>} \\
\columnbreak
\added{\tcode{<flat_map>}} \\
\tcode{<forward_list>} \\
\tcode{<fstream>} \\
\tcode{<functional>} \\
\tcode{<future>} \\
\tcode{<initializer_list>} \\
\tcode{<iomanip>} \\
\tcode{<ios>} \\
\tcode{<iosfwd>} \\
\tcode{<iostream>} \\
\tcode{<istream>} \\
\tcode{<iterator>} \\
\tcode{<limits>} \\
\tcode{<list>} \\
\tcode{<locale>} \\
\tcode{<map>} \\
\tcode{<memory>} \\
\tcode{<memory_resource>} \\
\columnbreak
\tcode{<mutex>} \\
\tcode{<new>} \\
\tcode{<numeric>} \\
\tcode{<optional>} \\
\tcode{<ostream>} \\
\tcode{<queue>} \\
\tcode{<random>} \\
\tcode{<ranges>} \\
\tcode{<ratio>} \\
\tcode{<regex>} \\
\tcode{<scoped_allocator>} \\
\tcode{<set>} \\
\tcode{<shared_mutex>} \\
\tcode{<span>} \\
\tcode{<sstream>} \\
\tcode{<stack>} \\
\tcode{<stdexcept>} \\
\tcode{<streambuf>} \\
\columnbreak
\tcode{<string>} \\
\tcode{<string_view>} \\
\tcode{<strstream>} \\
\tcode{<syncstream>} \\
\tcode{<system_error>} \\
\tcode{<thread>} \\
\tcode{<tuple>} \\
\tcode{<typeindex>} \\
\tcode{<typeinfo>} \\
\tcode{<type_traits>} \\
\tcode{<unordered_map>} \\
\tcode{<unordered_set>} \\
\tcode{<utility>} \\
\tcode{<valarray>} \\
\tcode{<variant>} \\
\tcode{<vector>} \\
\tcode{<version>} \\
\end{multicolfloattable}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{chapter}{20}
\rSec0[containers]{Containers library}

\rSec1[containers.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to
organize collections of information.

\pnum
The following subclauses describe
container requirements,
and components for
sequence containers and
associative containers,
as summarized in Table 76.

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
21.2 & Requirements                     &                           \\ \rowsep
21.3              & Sequence containers              & \tcode{<array>}         \\
                             &                                  & \tcode{<deque>}         \\
                             &                                  & \tcode{<forward_list>}  \\
                             &                                  & \tcode{<list>}          \\
                             &                                  & \tcode{<vector>}        \\ \rowsep
21.4            & Associative containers           & \tcode{<map>}           \\
                             &                                  & \tcode{<set>}           \\ \rowsep
21.5                  & Unordered associative containers & \tcode{<unordered_map>} \\
                             &                                  & \tcode{<unordered_set>} \\ \rowsep
21.6     & Container adaptors               & \tcode{<queue>}         \\
                             &                                  & \tcode{<stack>}         \\
                             &                                  & \added{\tcode{<flat_map>}}      \\
 \rowsep
21.7                  & Views                            & \tcode{<span>}          \\ \rowsep
\end{libsumtab}


\setcounter{section}{2}
\setcounter{subsection}{2}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\rSec2[sequence.reqmts]{Sequence containers}

\pnum
A sequence container organizes a finite set of objects, all of the same type, into a strictly
linear arrangement. The library provides four basic kinds of sequence containers:
\tcode{vector}, \tcode{forward_list}, \tcode{list}, and \tcode{deque}. In addition,
\tcode{array} is provided as a sequence container which provides limited sequence operations
because it has a fixed number of elements. The library also provides container
adaptors that make it easy to construct abstract data types, such
as \tcode{stack}s, \tcode{queue}s, \added{\tcode{flat_map}s,
or \tcode{flat_multimap}s, }out of the basic sequence container kinds (or out
of other kinds of sequence containers).

\setcounter{subsection}{5}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\rSec2[associative.reqmts]{Associative containers}

\pnum
Associative containers provide fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
\tcode{set},
\tcode{multiset},
\tcode{map}
and
\tcode{multimap}.\added{  The library also provides container adaptors that
make it easy to construct abstract data types, such as \tcode{flat_map}s
or \tcode{flat_multimap}s, out of the basic sequence container kinds (or out
of other program-defined sequence containers).}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{Paras}{5}
\pnum
\changed{\tcode{iterator}
of an associative container is of the bidirectional iterator category.}
{An associative container's \tcode{iterator} meets the bidirectional iterator requirements.}
For associative containers where the value type is the same as the key type, both
\tcode{iterator}
and
\tcode{const_iterator}
are constant iterators. It is unspecified whether or not
\tcode{iterator}
and
\tcode{const_iterator}
are the same type.
\begin{note} \tcode{iterator} and \tcode{const_iterator} have identical semantics in this case, and \tcode{iterator} is convertible to \tcode{const_iterator}. Users can avoid violating the one-definition rule by always using \tcode{const_iterator} in their function parameter lists. \end{note}

\setcounter{chapter}{21}
\setcounter{section}{5}
\rSec1[container.adaptors]{Container adaptors}

\rSec2[container.adaptors.general]{In general}

 \pnum
The headers \tcode{<queue>}\changed{ and}{,} \tcode{<stack>}\added{, and
\tcode{<flat_map>}} define the container adaptors \tcode{queue},
\tcode{priority_queue}\changed{ and}{,} \tcode{stack}\added{, and
\tcode{flat_map}}.

\pnum
For container adaptors, no \tcode{swap} function throws an exception unless
that exception is thrown by the swap of the
adaptor's \tcode{Container}, \tcode{KeyContainer}, \tcode{MappedContainer}, or
\tcode{Compare} object (if any).

\begin{addedblock}
\pnum
For container adaptors that have them, the \tcode{insert}, \tcode{emplace},
and \tcode{erase} members shall affect the validity of iterators and
references to the adaptor's container(s) in the same way that the containers'
respective \tcode{insert}, \tcode{emplace}, and \tcode{erase} members do.

[\textit{Example:} A call to \tcode{flat_map<Key, T>::insert} invalidates all iterators to
the \tcode{flat_map}.]
\end{addedblock}

\pnum
A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:
\begin{itemize}
\item It has an \tcode{InputIterator} template parameter and a type that does not qualify as an input iterator is deduced for that parameter.
\item It has a \tcode{Compare} template parameter and a type that qualifies as an allocator is deduced for that parameter.
uced for that parameter.
\item It has a \tcode{Container}\added{, \tcode{KeyContainer}, or \tcode{MappedContainer}} template parameter and a type that qualifies as an allocator is deduced for that parameter.
\item It has an \tcode{Allocator} template parameter and a type that does not qualify as an allocator is deduced for that parameter.
\item It has both \tcode{Container} and \tcode{Allocator} template parameters, and \tcode{uses_allocator_v<Container, Allocator>} is \tcode{false}.
\item \added{It has both \tcode{KeyContainer} and \tcode{Allocator} template parameters, and \\
\tcode{uses_allocator_v<KeyContainer, Allocator>} is \tcode{false}.}
\item \added{It has both \tcode{MappedContainer} and \tcode{Allocator} template parameters, and \\
\tcode{uses_allocator_v<MappedContainer, Allocator>} is \tcode{false}.}
\end{itemize}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{3}
\begin{addedblock}
\rSec2[flatmap.syn]{Header \tcode{<flat_map>} synopsis}%
\indexhdr{flatmap}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{flatmap}, class template \tcode{flat_map}
  template<class Key, class T, class Compare = less<Key>,
           class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
    class flat_map;

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator==(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator!=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator< (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator> (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator<=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator>=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    void swap(flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
              flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;

  struct sorted_unique_t { explicit sorted_unique_t() = default; };
  inline constexpr sorted_unique_t sorted_unique {};

  // \ref{flatmultimap}, class template \tcode{flat_multimap}
  template<class Key, class T, class Compare = less<Key>,
           class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
    class flat_multimap;

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator==(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator!=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator< (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator> (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator<=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    bool operator>=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                    const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    void swap(flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
              flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;

  struct sorted_equivalent_t { explicit sorted_equivalent_t() = default; };
  inline constexpr sorted_equivalent_t sorted_equivalent {};
}
\end{codeblock}
\end{addedblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{7}
\begin{addedblock}
\rSec2[flatmap]{Class template \tcode{flat_map}}

\pnum
\indexlibrary{\idxcode{flatmap}}%
A \tcode{flat_map} is a container adaptor that provides an associative
container interface that supports unique keys (contains at most one of each
key value) and provides for fast retrieval of values of another type \tcode{T}
based on the keys. \tcode{flat_map} supports input iterators that model
the \libconcept{RandomAccessIterator} (22.3.4.13) concept.

\pnum
A \tcode{flat_map} satisfies all of the requirements of a container, of a
reversible container (21.2), and of an associative
container (21.2.6), except for the requirements related to
node handles (21.2.4) and iterator
invalidation (21.2.1).  A \tcode{flat_map} does not
meet the additional requirements of an allocator-aware container, as described
in Table 65.

\pnum
A \tcode{flat_map} also provides most operations described
in (21.2.6) for unique keys.  This means that a
\tcode{flat_map} supports the \tcode{a_uniq} operations
in (21.2.6) but not the \tcode{a_eq} operations.  For
a \tcode{flat_map<Key,T>} the \tcode{key_type} is \tcode{Key} and the
\tcode{value_type} is \tcode{pair<const Key,T>}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_map} that
are not described in one of those tables or for operations where there is
additional semantic information.

\pnum
A \tcode{flat_map} maintains the following invariants: it contains the same
number of keys and values; the keys are sorted with respect to the comparison
object; and the value at offset \tcode{o} within the value container is the
value associated with the key at offset \tcode{o} within the key container.

\pnum
Any sequence container supporting random access iteration can be used to
instantiate \tcode{flat_map}. In particular, \tcode{vector} (21.3.11) and
\tcode{deque} (21.3.8) can be used.

\pnum
The program is ill-formed if the template parameters \tcode{Key} and \tcode{T}
of \tcode{flat_map} are not the same types as \tcode{KeyContainer::value_type}
and \tcode{MappedContainer::value_type}, respectively.

\pnum
The effect of calling a constructor that takes both \tcode{key_container_type}
and \tcode{mapped_container_type} arguments with containers of different sizes is
undefined.

\pnum
Constructors that take a \tcode{Container} argument \tcode{cont} shall
participate in overload resolution only if both \tcode{std::begin(cont)} and
\tcode{std::end(cont)} are well-formed expressions.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_unique_t}
argument with a range that is not sorted with respect to \tcode{compare}, or
that contains equal elements, is undefined.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{uses_allocator_v<key_container_type, Alloc> ||
  uses_allocator_v<mapped_container_type, Alloc>} is \tcode{true}.

\pnum
Constructors that take an Alloc argument shall participate in
overload resolution only if Alloc qualifies as allocator as described
in (21.2.1).

\rSec3[flatmap.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_map {
  public:
    // types:
    using key_type                  = Key;
    using mapped_type               = T;
    using value_type                = pair<const key_type, mapped_type>;
    using key_compare               = Compare;
    using reference                 = pair<const key_type&, mapped_type&>;
    using const_reference           = pair<const key_type&, const mapped_type&>;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_map::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_map::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using key_container_type        = KeyContainer;
    using mapped_container_type     = MappedContainer;

    class value_compare {
      friend class flat_map;
    protected:
      key_compare comp;
      value_compare(key_compare c) : comp(c) { }
    public:
      bool operator()(const_reference x, const_reference y) const {
        return comp(x.first, y.first);
      }
    };

    struct containers
    {
      key_container_type keys;
      mapped_container_type values;
    };

    // \ref{flatmap.cons}, construct/copy/destroy
    flat_map() : flat_map(key_compare()) { }

    flat_map(key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
             const Alloc& a)
        : flat_map(key_container_type(std::move(key_cont), a),
                   mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      explicit flat_map(const Container& cont)
        : flat_map(std::begin(cont), std::end(cont), key_compare()) { }
    template <class Container, class Alloc>
      flat_map(const Container& cont, const Alloc& a)
        : flat_map(std::begin(cont), std::end(cont), key_compare(), a) { }

    flat_map(sorted_unique_t,
             key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    flat_map(sorted_unique_t s, key_container_type key_cont,
             mapped_container_type mapped_cont, const Alloc& a)
        : flat_map(s, key_container_type(std::move(key_cont), a),
                   mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      flat_map(sorted_unique_t s, const Container& cont)
        : flat_map(s, std::begin(cont), std::end(cont), key_compare()) { }
    template <class Container, class Alloc>
      flat_map(sorted_unique_t s, const Container& cont, const Alloc& a)
        : flat_map(s, std::begin(cont), std::end(cont), key_compare(), a) { }

    explicit flat_map(const key_compare& comp)
      : c(containers()), compare(comp) { }
    template <class Alloc>
      flat_map(const key_compare& comp, const Alloc& a);
    template <class Alloc>
      explicit flat_map(const Alloc& a)
        : flat_map(key_compare(), a) { }

    template <class InputIterator>
      flat_map(InputIterator first, InputIterator last,
               const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_map(InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      flat_map(InputIterator first, InputIterator last,
               const Alloc& a)
        : flat_map(first, last, key_compare(), a) { }

    template <class InputIterator>
      flat_map(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_map(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      flat_map(sorted_unique_t s, InputIterator first, InputIterator last,
               const Alloc& a)
        : flat_map(s, first, last, key_compare(), a) { }

    template <class Alloc>
      flat_map(flat_map&& m, const Alloc& a)
        : c{key_container_type(std::move(m.c.keys), a),
            mapped_container_type(std::move(m.c.values), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      flat_map(const flat_map& m, const Alloc& a)
        : c{key_container_type(m.c.keys, a),
            mapped_container_type(m.c.values, a)}
        , compare{m.compare}
      { }

    flat_map(initializer_list<value_type>&& il,
             const key_compare& comp = key_compare())
        : flat_map(il, comp) { }
    template <class Alloc>
      flat_map(initializer_list<value_type>&& il,
               const key_compare& comp, const Alloc& a)
        : flat_map(il, comp, a) { }
    template <class Alloc>
      flat_map(initializer_list<value_type>&& il, const Alloc& a)
        : flat_map(il, key_compare(), a) { }

    flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
             const key_compare& comp = key_compare())
        : flat_map(s, il, comp) { }
    template <class Alloc>
      flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
               const key_compare& comp, const Alloc& a)
        : flat_map(s, il, comp, a) { }
    template <class Alloc>
      flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
               const Alloc& a)
        : flat_map(s, il, key_compare(), a) { }

    flat_map& operator=(initializer_list<value_type> il);

    // iterators
    iterator                begin() noexcept;
    const_iterator          begin() const noexcept;
    iterator                end() noexcept;
    const_iterator          end() const noexcept;

    reverse_iterator        rbegin() noexcept;
    const_reverse_iterator  rbegin() const noexcept;
    reverse_iterator        rend() noexcept;
    const_reverse_iterator  rend() const noexcept;

    const_iterator          cbegin() const noexcept;
    const_iterator          cend() const noexcept;
    const_reverse_iterator  crbegin() const noexcept;
    const_reverse_iterator  crend() const noexcept;

    // \ref{flatmap.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatmap.access}, element access
    mapped_type& operator[](const key_type& x);
    mapped_type& operator[](key_type&& x);
    mapped_type& at(const key_type& x);
    const mapped_type& at(const key_type& x) const;

    // \ref{flatmap.modifiers}, modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& x);
    pair<iterator, bool> insert(value_type&& x);
    template <class P> pair<iterator, bool> insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class P>
      iterator insert(const_iterator position, P&&);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);
    void insert(sorted_unique_t, initializer_list<value_type> il);

    containers extract() &&;
    void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);

    template <class... Args>
      pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template <class... Args>
      pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, const key_type& k,
                           Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template <class M>
      pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template <class M>
      pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, const key_type& k,
                                M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_map& fm) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    const key_container_type& keys() const      { return c.keys; }
    const mapped_container_type& values() const { return c.values; }

    // map operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
    containers c;        // \expos
    key_compare compare; // \expos
  };

  template<class Container>
    using @\placeholder{cont-key-type}@ =
      remove_const_t<typename Container::value_type::first_type>;         // \expos
  template<class Container>
    using @\placeholder{cont-mapped-type}@ =
      typename Container::value_type::second_type;                        // \expos
  template<class InputIterator>
    using @\placeholder{iter-key-type}@ = remove_const_t<
      typename iterator_traits<InputIterator>::value_type::first_type>;   // \expos
  template<class InputIterator>
    using @\placeholder{iter-mapped-type}@ =
      typename iterator_traits<InputIterator>::value_type::second_type;   // \expos

  template <class Container>
    flat_map(Container)
      -> flat_map<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer>
    flat_map(KeyContainer, MappedContainer)
      -> flat_map<typename KeyContainer::value_type,
                  typename MappedContainer::value_type,
                  less<typename KeyContainer::value_type>,
                  KeyContainer, MappedContainer>;

  template <class Container, class Alloc>
    flat_map(Container, Alloc)
      -> flat_map<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer, class Alloc>
    flat_map(KeyContainer, MappedContainer, Alloc)
      -> flat_map<typename KeyContainer::value_type,
                  typename MappedContainer::value_type,
                  less<typename KeyContainer::value_type>,
                  KeyContainer, MappedContainer>;

  template <class Container>
    flat_map(sorted_unique_t, Container)
      -> flat_map<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer>
    flat_map(sorted_unique_t, KeyContainer, MappedContainer)
      -> flat_map<typename KeyContainer::value_type,
                  typename MappedContainer::value_type,
                  less<typename KeyContainer::value_type>,
                  KeyContainer, MappedContainer>;

  template <class Container, class Alloc>
    flat_map(sorted_unique_t, Container, Alloc)
      -> flat_map<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer, class Alloc>
    flat_map(sorted_unique_t, KeyContainer, MappedContainer, Alloc)
      -> flat_map<typename KeyContainer::value_type,
                  typename MappedContainer::value_type,
                  less<typename KeyContainer::value_type>,
                  KeyContainer, MappedContainer>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-mapped-type}@<InputIterator>>>
    flat_map(InputIterator, InputIterator, Compare = Compare())
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_map(InputIterator, InputIterator, Compare, Alloc)
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_map(InputIterator, InputIterator, Alloc)
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-mapped-type}@<InputIterator>>>
    flat_map(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_map(sorted_unique_t, InputIterator, InputIterator, Compare, Alloc)
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_map(sorted_unique_t, InputIterator, InputIterator, Alloc)
      -> flat_map<@\placeholder{iter-mapped-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>>;

  template<class Key, class T, class Compare = less<Key>>
    flat_map(initializer_list<pair<Key, T>>, Compare = Compare())
      -> flat_map<Key, T, Compare>;

  template<class Key, class T, class Compare, class Alloc>
    flat_map(initializer_list<pair<Key, T>>, Compare, Alloc)
      -> flat_map<Key, T, Compare>;

  template<class Key, class T, class Alloc>
    flat_map(initializer_list<pair<Key, T>>, Alloc)
      -> flat_map<Key, T>;

  template<class Key, class T, class Compare = less<Key>>
  flat_map(sorted_unique_t, initializer_list<pair<Key, T>>, Compare = Compare())
      -> flat_map<Key, T, Compare>;

  template<class Key, class T, class Compare, class Alloc>
    flat_map(sorted_unique_t, initializer_list<pair<Key, T>>, Compare, Alloc)
      -> flat_map<Key, T, Compare>;

  template<class Key, class T, class Alloc>
    flat_map(sorted_unique_t, initializer_list<pair<Key, T>>, Alloc)
      -> flat_map<Key, T>;
}
\end{codeblock}

\rSec3[flatmap.cons]{Constructors}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
flat_map(key_container_type key_cont, mapped_container_type mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c.keys} with \tcode{std::move(key_cont)} and
\tcode{c.values} with \tcode{std::move(mapped_cont)}; value-initializes
\tcode{compare}; and sorts the range \range{begin()}{end()} with
\tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if
with \tcode{compare} and otherwise $N \log N$, where $N$
is \tcode{key_cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c.keys} with
\tcode{std::move(key_cont)} and \tcode{c.values} with
\tcode{std::move(mapped_cont)}; value-initializes \tcode{compare}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_map(InputIterator first, InputIterator last, const key_compare& comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, adds elements to
\tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if with
\tcode{compare} and otherwise $N \log N$, where $N$ is
\tcode{key_cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp = key_compare());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmap.cons.alloc]{Constructors with allocators}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
template <class Alloc>
  flat_map(const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_map(InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}; adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if with
\tcode{compare} and otherwise $N \log N$, where $N$ is
\tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmap}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}; adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmap.capacity]{Capacity}

\indexlibrarymember{size}{flatmap}%
\begin{itemdecl}
size_type size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return c.keys.size();}
\end{itemdescr}

\indexlibrarymember{max_size}{flatmap}%
\begin{itemdecl}
size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::min<size_type>(c.keys.max_size(), c.values.max_size());}
\end{itemdescr}

\rSec3[flatmap.access]{Access}

\indexlibrary{\idxcode{operator[]}!\idxcode{flatmap}}%
\begin{itemdecl}
mapped_type& operator[](const key_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return try_emplace(x).first->second;}
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{flatmap}}%
\begin{itemdecl}
mapped_type& operator[](key_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return try_emplace(std::move(x)).first->second;}
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{flatmap}}%
\begin{itemdecl}
mapped_type&       at(const key_type& x);
const mapped_type& at(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to the \tcode{mapped_type} corresponding to \tcode{x} in \tcode{*this}.

\pnum
\throws
An exception object of type \tcode{out_of_range} if
no such element is present.

\pnum
\complexity Logarithmic.
\end{itemdescr}

\rSec3[flatmap.modifiers]{Modifiers}

\indexlibrarymember{operator=}{flatmap}%
\begin{itemdecl}
flat_map& operator=(initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
clear();
insert(il);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{emplace}{flatmap}%
\begin{itemdecl}
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{pair<key_type, mapped_type>(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
First, constructs a \tcode{pair<key_type, value_type>} object \tcode{t}
constructed with \tcode{std::forward<Args>(args)...}.  If the map already
contains an element whose key is equivalent to the key of \tcode{t}, there is
no effect.  Otherwise, equivalent to:
\begin{codeblock}
auto key_it = std::lower_bound(std::begin(c.keys), std::end(c.keys), t.first, compare);
auto value_it = std::begin(c.values) + distance(std::begin(c.keys), key_it);
c.keys.emplace(key_it, std::move(t.first));
c.values.emplace(value_it, std::move(t.second));
\end{codeblock}

\pnum
\returns
The \tcode{bool} component of the returned pair is \tcode{true} if and only if
the insertion took place, and the iterator component of the pair points to the
element with key equivalent to the key of \tcode{t}.
\end{itemdescr}

\indexlibrarymember{insert}{flatmap}%
\begin{itemdecl}
template<class P> pair<iterator, bool> insert(P&& x);
template<class P> iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{pair<key_type, mapped_type>(std::forward<P>(x))} is well-formed.

\pnum
\effects
The first form is equivalent to
\tcode{return emplace(std::forward<P>(x))}. The second form is
equivalent to \tcode{return emplace_hint(position, std::forward<P>(x))}.
\end{itemdescr}

\indexlibrarymember{try_emplace}{flatmap}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{mapped_type(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
If the map already contains an element whose key is equivalent to \tcode{k},
there is no effect.  Otherwise equivalent to:
\begin{codeblock}
auto key_it = std::lower_bound(std::begin(c.keys), std::end(c.keys), k, compare);
auto value_it = std::begin(c.values) + distance(std::begin(c.keys), key_it);
c.keys.insert(key_it, k);
c.values.emplace(value_it, std::forward<Args>(args)...);
\end{codeblock}

\pnum
\returns
In the first overload, the \tcode{bool} component of the returned pair
is \tcode{true} if and only if the insertion took place.  The returned
iterator points to the map element whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{try_emplace}{flatmap}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{mapped_type(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
If the map already contains an element whose key is equivalent to \tcode{k},
there is no effect.  Otherwise equivalent to:
\begin{codeblock}
auto key_it = std::lower_bound(std::begin(c.keys), std::end(c.keys), k, compare);
auto value_it = std::begin(c.values) + distance(std::begin(c.keys), key_it);
c.keys.emplace(key_it, std::move(k));
c.values.emplace(value_it, std::forward<Args>(args)...);
\end{codeblock}

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{flatmap}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_assignable_v<mapped_type\&, M>} is \tcode{true}, and
\tcode{mapped_type(std::forward<M>(obj))} is well-formed.

\pnum
\effects
If the map already contains an element \tcode{e} whose key is equivalent
to \tcode{k}, assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise equivalent to \tcode{insert(k, std::forward<M>(obj))} or
\tcode{emplace(hint, k, std::forward<M>(obj))} respectively.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{flatmap}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_assignable_v<mapped_type\&, M>} is \tcode{true}, and
\tcode{mapped_type(std::forward<M>(obj))} is well-formed.

\pnum
\effects
If the map already contains an element \tcode{e}
whose key is equivalent to \tcode{k},
assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise equivalent to \tcode{insert(std::move(k), std::forward<M>(obj))} or
\tcode{emplace(hint, std::move(k), std::forward<M>(obj))} respectively.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{flatmap}{insert}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{flatmap}{insert}%
\begin{itemdecl}
void insert(sorted_unique_t, initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{insert(sorted_unique_t{}, il.begin(), il.end())}.
\end{itemdescr}

\indexlibrarymember{flatmap}{swap}%
\begin{itemdecl}
void swap(flat_map& fm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<key_container_type> \&\&
is_nothrow_swappable_v<mapped_container_type> \&\&
is_nothrow_swappable_v<key_compare>} is \tcode{true}.

\pnum \effects Equivalent to:
\begin{codeblock}
using std::swap;
swap(c.keys, fm.c.keys);
swap(c.values, fm.c.values);
swap(c.compare, fm.compare);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatmap}{extract}%
\begin{itemdecl}
containers extract() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{return std::move(c);}
\end{itemdescr}

\indexlibrarymember{flatmap}{replace}%
\begin{itemdecl}
void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
\tcode{key_cont.size() == mapped_cont.size()} is \tcode{true}, and the elements of
\tcode{key_cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c.keys = std::move(key_cont);
c.values = std::move(mapped_cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatmap.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator==(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::equal(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator!=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator< (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator> (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator<=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{flatmap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator>=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[flatmap.special]{Specialized algorithms}

\indexlibrarymember{swap}{flatmap}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  void swap(flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
            flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<KeyContainer> \&\&
is_nothrow_swappable_v<MappedContainer> \&\& is_nothrow_swappable_v<Compare>}
is \tcode{true}.

\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[flatmultimap]{Class template \tcode{flat_multimap}}

\pnum
\indexlibrary{\idxcode{flatmultimap}}%
A \tcode{flat_multimap} is a container adaptor that provides an associative
container interface that supports equivalent keys (possibly containing
multiple copies of the same key value) and provides for fast retrieval of
values of another type \tcode{T} based on the keys. \tcode{flat_multimap}
supports input iterators that model the
\libconcept{RandomAccessIterator} (22.3.4.13) concept.

\pnum
A \tcode{flat_multimap} satisfies all of the requirements of a container, of a
reversible container (21.2), and of an associative
container (21.2.6), except for the requirements related to
node handles (21.2.4) and iterator
invalidation (21.2.1).  A \tcode{flat_multimap} does
not meet the additional requirements of an allocator-aware container, as
described in Table 65.

\pnum
A \tcode{flat_multimap} also provides most operations described
in (21.2.6) for equal keys.  This means that a
\tcode{flat_multimap} supports the \tcode{a_eq} operations
in (21.2.6) but not the \tcode{a_uniq} operations.  For
a \tcode{flat_multimap<Key,T>} the \tcode{key_type} is \tcode{Key} and the
\tcode{value_type} is \tcode{pair<const Key,T>}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_multimap}
that are not described in one of those tables or for operations where
there is additional semantic information.

\pnum
A \tcode{flat_multimap} maintains the following invariants: it contains the
same number of keys and values; the keys are sorted with respect to the
comparison object; and the value at offset \tcode{o} within the value
container is the value associated with the key at offset \tcode{o} within the
key container.

\pnum
Any sequence container supporting random access iteration can be used to
instantiate \tcode{flat_multimap}. In particular, \tcode{vector} (21.3.11)
and \tcode{deque} (21.3.8) can be used.

\pnum
The program is ill-formed if the template parameters \tcode{Key} and \tcode{T}
of \tcode{flat_multimap} are not the same types as \tcode{KeyContainer::value_type}
and \tcode{MappedContainer::value_type}, respectively.

\pnum
The effect of calling a constructor that takes both \tcode{key_container_type}
and \tcode{mapped_container_type} arguments with containers of different sizes is
undefined.

\pnum
Constructors that take a \tcode{Container} argument \tcode{cont} shall
participate in overload resolution only if both \tcode{std::begin(cont)}
and \tcode{std::end(cont)} are well-formed expressions.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_equivalent_t}
argument with a container or containers that are not sorted with respect
to \tcode{key_compare} is undefined.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{uses_allocator_v<key_container_type, Alloc> ||
  uses_allocator_v<mapped_container_type, Alloc>} is \tcode{true}.

\pnum
Constructors that take an Alloc argument shall participate in
overload resolution only if Alloc qualifies as allocator as described
in (21.2.1).

\rSec3[flatmultimap.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_multimap {
  public:
    // types:
    using key_type                  = Key;
    using mapped_type               = T;
    using value_type                = pair<const key_type, mapped_type>;
    using key_compare               = Compare;
    using reference                 = pair<const key_type&, mapped_type&>;
    using const_reference           = pair<const key_type&, const mapped_type&>;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_multimap::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_multimap::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using key_container_type        = KeyContainer;
    using mapped_container_type     = MappedContainer;

    class value_compare {
      friend class flat_multimap;
    protected:
      key_compare comp;
      value_compare(key_compare c) : comp(c) { }
    public:
      bool operator()(const_reference x, const_reference y) const {
        return comp(x.first, y.first);
      }
    };

    struct containers
    {
      key_container_type keys;
      mapped_container_type values;
    };

    // \ref{flatmultimap.cons}, construct/copy/destroy
    flat_multimap() : flat_multimap(key_compare()) { }

    flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
                  const Alloc& a)
        : flat_multimap(key_container_type(std::move(key_cont), a),
                        mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      explicit flat_multimap(const Container& cont)
        : flat_multimap(std::begin(cont), std::end(cont), key_compare()) { }
    template <class Container, class Alloc>
      flat_multimap(const Container& cont, const Alloc& a)
        : flat_multimap(std::begin(cont), std::end(cont), key_compare(), a) { }

    flat_multimap(sorted_equivalent_t,
                  key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    flat_multimap(sorted_equivalent_t, key_container_type key_cont,
                  mapped_container_type mapped_cont, const Alloc& a)
        : flat_multimap(key_container_type(std::move(key_cont), a),
                        mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      flat_multimap(sorted_equivalent_t s, const Container& cont)
        : flat_multimap(s, std::begin(cont), std::end(cont), key_compare()) { }
    template <class Container, class Alloc>
      flat_multimap(sorted_equivalent_t s, const Container& cont, const Alloc& a)
        : flat_multimap(s, std::begin(cont), std::end(cont), key_compare(), a) { }

    explicit flat_multimap(const key_compare& comp)
      : c(containers()), compare(comp) { }
    template <class Alloc>
      flat_multimap(const key_compare& comp, const Alloc& a);
    template <class Alloc>
      explicit flat_multimap(const Alloc& a)
        : flat_multimap(key_compare(), a) { }

    template <class InputIterator>
      flat_multimap(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_multimap(InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      flat_multimap(InputIterator first, InputIterator last,
                    const Alloc& a)
        : flat_multimap(first, last, key_compare(), a) { }

    template <class InputIterator>
      flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const Alloc& a)
        : flat_multimap(s, first, last, key_compare(), a) { }

    template <class Alloc>
      flat_multimap(flat_multimap&& m, const Alloc& a)
        : c{key_container_type(std::move(m.c.keys), a),
            mapped_container_type(std::move(m.c.values), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      flat_multimap(const flat_multimap& m, const Alloc& a)
        : c{key_container_type(m.c.keys, a), mapped_container_type(m.c.values, a)}
        , compare{m.compare}
      { }

    flat_multimap(initializer_list<value_type>&& il,
                  const key_compare& comp = key_compare())
        : flat_multimap(il, comp) { }
    template <class Alloc>
      flat_multimap(initializer_list<value_type>&& il,
                    const key_compare& comp, const Alloc& a)
        : flat_multimap(il, comp, a) { }
    template <class Alloc>
      flat_multimap(initializer_list<value_type>&& il, const Alloc& a)
        : flat_multimap(il, key_compare(), a) { }

    flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                  const key_compare& comp = key_compare())
        : flat_multimap(s, il, comp) { }
    template <class Alloc>
      flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                    const key_compare& comp, const Alloc& a)
        : flat_multimap(s, il, comp, a) { }
    template <class Alloc>
      flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                    const Alloc& a)
        : flat_multimap(s, il, key_compare(), a) { }

    flat_multimap& operator=(initializer_list<value_type> il);

    // iterators
    iterator                begin() noexcept;
    const_iterator          begin() const noexcept;
    iterator                end() noexcept;
    const_iterator          end() const noexcept;

    reverse_iterator        rbegin() noexcept;
    const_reverse_iterator  rbegin() const noexcept;
    reverse_iterator        rend() noexcept;
    const_reverse_iterator  rend() const noexcept;

    const_iterator          cbegin() const noexcept;
    const_iterator          cend() const noexcept;
    const_reverse_iterator  crbegin() const noexcept;
    const_reverse_iterator  crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatmultimap.modifiers}, modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& x);
    pair<iterator, bool> insert(value_type&& x);
    template <class P> pair<iterator, bool> insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class P>
      iterator insert(const_iterator position, P&&);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);
    void insert(sorted_equivalent_t, initializer_list<value_type> il);

    containers extract() &&;
    void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_multimap& fm) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    const key_container_type& keys() const      { return c.keys; }
    const mapped_container_type& values() const { return c.values; }

    // map operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
    containers c;        // \expos
    key_compare compare; // \expos
  };

  template<class Container>
    using @\placeholder{cont-key-type}@ =
      remove_const_t<typename Container::value_type::first_type>;          // \expos
  template<class Container>
    using @\placeholder{cont-mapped-type}@ =
      typename Container::value_type::second_type;                        // \expos
  template<class InputIterator>
    using @\placeholder{iter-key-type}@ = remove_const_t<
      typename iterator_traits<InputIterator>::value_type::first_type>;   // \expos
  template<class InputIterator>
    using @\placeholder{iter-mapped-type}@ =
      typename iterator_traits<InputIterator>::value_type::second_type;   // \expos

  template <class Container>
    flat_multimap(Container)
      -> flat_multimap<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer>
    flat_multimap(KeyContainer, MappedContainer)
      -> flat_multimap<typename KeyContainer::value_type,
                       typename MappedContainer::value_type,
                       less<typename KeyContainer::value_type>,
                       KeyContainer, MappedContainer>;

  template <class Container, class Alloc>
    flat_multimap(Container, Alloc)
      -> flat_multimap<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer, class Alloc>
    flat_multimap(KeyContainer, MappedContainer, Alloc)
      -> flat_multimap<typename KeyContainer::value_type,
                       typename MappedContainer::value_type,
                       less<typename KeyContainer::value_type>,
                       KeyContainer, MappedContainer>;

  template <class Container>
    flat_multimap(sorted_equivalent_t, Container)
      -> flat_multimap<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer>
    flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer)
      -> flat_multimap<typename KeyContainer::value_type,
                       typename MappedContainer::value_type,
                       less<typename KeyContainer::value_type>,
                       KeyContainer, MappedContainer>;

  template <class Container, class Alloc>
    flat_multimap(sorted_equivalent_t, Container, Alloc)
      -> flat_multimap<@\placeholder{cont-key-type}@<Container>, @\placeholder{cont-mapped-type}@<Container>>;

  template <class KeyContainer, class MappedContainer, class Alloc>
    flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Alloc)
      -> flat_multimap<typename KeyContainer::value_type,
                       typename MappedContainer::value_type,
                       less<typename KeyContainer::value_type>,
                       KeyContainer, MappedContainer>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>>
    flat_multimap(InputIterator, InputIterator, Compare = Compare())
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_multimap(InputIterator, InputIterator, Compare, Alloc)
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_multimap(InputIterator, InputIterator, Alloc)
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>>
    flat_multimap(sorted_equivalent_t, InputIterator, InputIterator,
                  Compare = Compare())
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_multimap(sorted_equivalent_t, InputIterator, InputIterator, Compare, Alloc)
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_multimap(sorted_equivalent_t, InputIterator, InputIterator, Alloc)
      -> flat_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>>;

  template<class Key, class T, class Compare = less<Key>>
    flat_multimap(initializer_list<pair<Key, T>>, Compare = Compare())
      -> flat_multimap<Key, T, Compare>;

  template<class Key, class T, class Compare, class Alloc>
    flat_multimap(initializer_list<pair<Key, T>>, Compare, Alloc)
      -> flat_multimap<Key, T, Compare>;

  template<class Key, class T, class Alloc>
    flat_multimap(initializer_list<pair<Key, T>>, Alloc)
      -> flat_multimap<Key, T>;

  template<class Key, class T, class Compare = less<Key>>
  flat_multimap(sorted_equivalent_t, initializer_list<pair<Key, T>>,
                Compare = Compare())
      -> flat_multimap<Key, T, Compare>;

  template<class Key, class T, class Compare, class Alloc>
    flat_multimap(sorted_equivalent_t, initializer_list<pair<Key, T>>, Compare, Alloc)
      -> flat_multimap<Key, T, Compare>;

  template<class Key, class T, class Alloc>
    flat_multimap(sorted_equivalent_t, initializer_list<pair<Key, T>>, Alloc)
      -> flat_multimap<Key, T>;
}
\end{codeblock}

\rSec3[flatmultimap.cons]{Constructors}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c.keys} with \tcode{std::move(key_cont)} and
\tcode{c.values} with \tcode{std::move(mapped_cont)}; value-initializes
\tcode{compare}; and sorts the range \range{begin()}{end()} with
\tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if
with \tcode{compare} and otherwise $N \log N$, where $N$
is \tcode{key_cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
flat_multimap(sorted_equivalent_t, key_container_type key_cont,
              mapped_container_type mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c.keys} with
\tcode{std::move(key_cont)} and \tcode{c.values} with
\tcode{std::move(mapped_cont)}; value-initializes \tcode{compare}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_multimap(InputIterator first, InputIterator last, const key_compare& comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, adds elements to
\tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if with
\tcode{compare} and otherwise $N \log N$, where $N$ is
\tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp = key_compare());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmultimap.cons.alloc]{Constructors with allocators}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
template <class Alloc>
  flat_multimap(const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_multimap(InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}; adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if the container arguments are already sorted as if with
\tcode{compare} and otherwise $N \log N$, where $N$ is
\tcode{key_cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultimap}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of both
\tcode{c.keys} and \tcode{c.values} with \tcode{a}; adds elements to
\tcode{c.keys} and \tcode{c.values} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.keys.insert(std::end(c.keys), first->first);
  c.values.insert(std::end(c.values), first->second);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmultimap.capacity]{Capacity}

\indexlibrarymember{size}{flatmultimap}%
\begin{itemdecl}
size_type size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return c.keys.size();}
\end{itemdescr}

\indexlibrarymember{max_size}{flatmultimap}%
\begin{itemdecl}
size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::min<size_type>(c.keys.max_size(), c.values.max_size());}
\end{itemdescr}

\rSec3[flatmultimap.modifiers]{Modifiers}

\indexlibrarymember{operator=}{flatmultimap}%
\begin{itemdecl}
flat_multimap& operator=(initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
clear();
insert(il);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{emplace}{flatmultimap}%
\begin{itemdecl}
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{pair<key_type,
mapped_type>(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
First, constructs a \tcode{pair<key_type, value_type>} object \tcode{t}
constructed with \tcode{std::forward<Args>(args)...}, then inserts \tcode{t}
as if by:
\begin{codeblock}
auto key_it = std::upper_bound(std::begin(c.keys), std::end(c.keys), t.first);
auto value_it = std::begin(c.values) + distance(std::begin(c.keys), key_it);
c.keys.emplace(key_it, std::move(t.first));
c.values.emplace(value_it, std::move(t.second));
\end{codeblock}

\pnum
\returns
An iterator that points to the inserted element.
\end{itemdescr}

\indexlibrarymember{insert}{flatmultimap}%
\begin{itemdecl}
template<class P> iterator insert(P&& x);
template<class P> iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{pair<key_type, mapped_type>(std::forward<P>(x))} is well-formed.

\pnum
\effects
The first form is equivalent to
\tcode{return emplace(std::forward<P>(x))}. The second form is
equivalent to \tcode{return emplace_hint(position, std::forward<P>(x))}.
\end{itemdescr}

\indexlibrarymember{flatmultimap}{insert}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{flatmultimap}{insert}%
\begin{itemdecl}
void insert(sorted_equivalent_t, initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{insert(sorted_equivalent_t{}, il.begin(), il.end())}.
\end{itemdescr}

\indexlibrarymember{flatmultimap}{swap}%
\begin{itemdecl}
void swap(flat_multimap& fm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<key_container_type> \&\&
is_nothrow_swappable_v<mapped_container_type> \&\&
is_nothrow_swappable_v<key_compare>} is \tcode{true}.

\pnum \effects Equivalent to:
\begin{codeblock}
using std::swap;
swap(c.keys, fm.c.keys);
swap(c.values, fm.c.values);
swap(c.compare, fm.compare);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatmultimap}{extract}%
\begin{itemdecl}
containers extract() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{return std::move(c);}
\end{itemdescr}

\indexlibrarymember{flatmultimap}{replace}%
\begin{itemdecl}
void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
\tcode{key_cont.size() == mapped_cont.size()} is \tcode{true}, and the elements of
\tcode{key_cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c.keys = std::move(key_cont);
c.values = std::move(mapped_cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatmultimap.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator==(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::equal(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator!=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator< (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator> (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator<=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{flatmultimap}}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  bool operator>=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
                  const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[flatmultimap.special]{Specialized algorithms}

\indexlibrarymember{swap}{flatmultimap}%
\begin{itemdecl}
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer>
  void swap(flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
            flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<KeyContainer> \&\&
is_nothrow_swappable_v<MappedContainer> \&\& is_nothrow_swappable_v<Compare>}
is \tcode{true}.

\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}
\end{addedblock}
