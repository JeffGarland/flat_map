%!TEX root = std.tex
\setcounter{chapter}{20}
\rSec0[containers]{Containers library}

\rSec1[containers.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to
organize collections of information.

\pnum
The following subclauses describe
container requirements,
and components for
sequence containers and
associative containers,
as summarized in Table 76.

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
26.2 & Requirements                     &                           \\ \rowsep
26.3              & Sequence containers              & \tcode{<array>}         \\
                             &                                  & \tcode{<deque>}         \\
                             &                                  & \tcode{<forward_list>}  \\
                             &                                  & \tcode{<list>}          \\
                             &                                  & \tcode{<vector>}        \\ \rowsep
26.4            & Associative containers           & \tcode{<map>}           \\
                             &                                  & \tcode{<set>}           \\ \rowsep
26.5                  & Unordered associative containers & \tcode{<unordered_map>} \\
                             &                                  & \tcode{<unordered_set>} \\ \rowsep
26.6     & Container adaptors               & \tcode{<queue>}         \\
                             &                                  & \tcode{<stack>}         \\
                             &                                  & \tcode{<flat_map>}      \\
                             &                                  & \added{\tcode{<flat_set>}}      \\
 \rowsep
26.7                  & Views                            & \tcode{<span>}          \\ \rowsep
\end{libsumtab}


\setcounter{section}{2}
\setcounter{subsection}{2}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\rSec2[sequence.reqmts]{Sequence containers}

\pnum
A sequence container organizes a finite set of objects, all of the same type, into a strictly
linear arrangement. The library provides four basic kinds of sequence containers:
\tcode{vector}, \tcode{forward_list}, \tcode{list}, and \tcode{deque}. In addition,
\tcode{array} is provided as a sequence container which provides limited sequence operations
because it has a fixed number of elements. The library also provides container
adaptors that make it easy to construct abstract data types, such
as \tcode{stack}s, \tcode{queue}s, \tcode{flat_map}s\changed{ or}{,}
\tcode{flat_multimap}s\added{, \tcode{flat_set}s, or \tcode{flat_multiset}s},
out of the basic sequence container kinds (or out of other kinds of sequence
containers).

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{5}
\rSec2[associative.reqmts]{Associative containers}

\pnum
Associative containers provide fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
\tcode{set},
\tcode{multiset},
\tcode{map}
and
\tcode{multimap}. The library also provides container adaptors that
make it easy to construct abstract data types, such as \tcode{flat_map}s\changed{ or}{,}
\tcode{flat_multimap}s\added{, \tcode{flat_set}s, or \tcode{flat_multiset}s}, out of
the basic sequence container kinds (or out of other program-defined sequence
containers).

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{chapter}{21}
\setcounter{section}{5}
\rSec1[container.adaptors]{Container adaptors}

\rSec2[container.adaptors.general]{In general}

\pnum
The headers \tcode{<queue>}, \tcode{<stack>},\removed{ and}
\tcode{<flat_map>}\added{, and \tcode{<flat_set>}} define the container adaptors
\tcode{queue}, \tcode{priority_queue}, \tcode{stack},\removed{ and}
\tcode{flat_map}\added{, and \tcode{flat_set}}.

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{3}
\begin{addedblock}
\rSec2[flatset.syn]{Header \tcode{<flat_set>} synopsis}%
\indexhdr{flatset}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{flatset}, class template \tcode{flat_set}
  template<class Key, class Compare = less<Key>, class Container = vector<Key>>
    class flat_set;

  template<class Key, class Compare, class Container>
    bool operator==(const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator!=(const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator< (const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator> (const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator<=(const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator>=(const flat_set<Key, Compare, Container>& x,
                    const flat_set<Key, Compare, Container>& y);

  template<class Key, class Compare, class Container>
    void swap(flat_set<Key, Compare, Container>& x,
              flat_set<Key, Compare, Container>& y) noexcept;

  // \ref{flatmultiset}, class template \tcode{flat_multiset}
  template<class Key, class Compare = less<Key>, class Container = vector<Key>>
    class flat_multiset;

  template<class Key, class Compare, class Container>
    bool operator==(const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator!=(const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator< (const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator> (const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator<=(const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    bool operator>=(const flat_multiset<Key, Compare, Container>& x,
                    const flat_multiset<Key, Compare, Container>& y);

  template<class Key, class Compare, class Container>
    void swap(flat_multiset<Key, Compare, Container>& x,
              flat_multiset<Key, Compare, Container>& y) noexcept;
}
\end{codeblock}
\end{addedblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\begin{addedblock}
\rSec2[flatset]{Class template \tcode{flat_set}}

\pnum
\indexlibrary{\idxcode{flatset}}%
A \tcode{flat_set} is a container adaptor that provides an associative
container interface that supports unique keys (contains at most one of each
key value) and provides for fast retrieval of the keys themselves. The
\tcode{flat_set} class supports random access iterators.

\pnum
A \tcode{flat_set} satisfies all of the requirements of a container, of a
reversible container (21.2), and of an associative
container (21.2.6), except for the requirements related to
node handles (21.2.4) and iterator
invalidation (21.6.1).  A \tcode{flat_set} does not
meet the additional requirements of an allocator-aware container, as described
in Table 80.

\pnum
A \tcode{flat_set} also provides most operations described
in~\ref{associative.reqmts} for unique keys.  This means that a
\tcode{flat_set} supports the \tcode{a_uniq} operations
in~\ref{associative.reqmts} but not the \tcode{a_eq} operations.  For a
\tcode{flat_set<Key>} both the \tcode{key_type} and \tcode{mapped_type} are
\tcode{Key}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_set} that
are not described in one of those tables or for operations where there is
additional semantic information.

\pnum
Any sequence container supporting random access iteration can be used to
instantiate \tcode{flat_set}. In particular, \tcode{vector} (26.3.11) and
\tcode{deque} (26.3.8) can be used.

\pnum
The template parameter \tcode{Key} shall denote the same type as
\tcode{Container::value_type}.

\pnum
Constructors that take a \tcode{Container} argument \tcode{cont} shall
participate in overload resolution only if both \tcode{std::begin(cont)} and
\tcode{std::end(cont)} are well-formed expressions.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_unique_t}
argument with a range that is not sorted with respect to \tcode{compare}, or
that contains equal elements, is undefined.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{uses_allocator_v<container_type, Alloc>} is
\tcode{true}.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{Alloc} meets the allocator requirements as described
in (21.2.1).

\rSec3[flatset.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>, class Container = vector<Key>>
  class flat_set {
  public:
    // types:
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_set::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_set::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = Container;

    // \ref{flatset.cons}, construct/copy/destroy
    flat_set() : flat_set(key_compare()) { }

    explicit flat_set(container_type);
    template <class Alloc>
      flat_set(container_type cont, const Alloc& a)
        : flat_set(container_type(std::move(key), a)) { }
    template <class Container>
      explicit flat_set(const Container& cont)
        : flat_set(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      flat_set(const Container& cont, const Alloc& a)
        : flat_set(cont.begin(), cont.end(), key_compare(), a) { }

    flat_set(sorted_unique_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Alloc>
      flat_set(sorted_unique_t s, container_type cont, const Alloc& a)
        : flat_set(s, key_container_type(std::move(key_cont), a)) { }
    template <class Container>
      flat_set(sorted_unique_t s, const Container& cont)
        : flat_set(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      flat_set(sorted_unique_t s, const Container& cont, const Alloc& a)
        : flat_set(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit flat_set(const key_compare& comp)
      : c(container_type()), compare(comp) { }
    template <class Alloc>
      flat_set(const key_compare& comp, const Alloc&);
    template <class Alloc>
      explicit flat_set(const Alloc&) 
        : flat_set(key_compare(), a) { }

    template <class InputIterator>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      flat_set(InputIterator first, InputIterator last, const Alloc& a)
        : flat_set(first, last, key_compare(), a) { }

    template <class InputIterator>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Alloc>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      flat_set(sorted_unique_t s, InputIterator first, InputIterator last,
               const Alloc& a)
        : flat_set(s, first, last, key_compare(), a) { }

    template <class Alloc>
      flat_set(flat_set&& m, const Alloc& a)
        : c{container_type(std::move(m.c), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      flat_set(const flat_set& m, const Alloc& a)
        : c{container_type(m.c, a)}
        , compare{m.compare}
      { }

    flat_set(initializer_list<key_type>&& il,
             const key_compare& comp = key_compare())
        : flat_set(il, comp) { }
    template <class Alloc>
      flat_set(initializer_list<key_type>&& il,
               const key_compare& comp, const Alloc& a)
        : flat_set(il, comp, a) { }
    template <class Alloc>
      flat_set(initializer_list<key_type>&& il, const Alloc& a)
        : flat_set(il, key_compare(), a) { }

    flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
             const key_compare& comp = key_compare()) 
        : flat_set(s ,il, comp) { }
    template <class Alloc>
      flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
               const key_compare& comp, const Alloc& a) 
        : flat_set(s, il, comp, a) { }
    template <class Alloc>
      flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
               const Alloc& a)
        : flat_set(s, il, key_compare(), a) { }

    flat_set& operator=(initializer_list<key_type>);

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // \ref{flatset.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatset.modifiers}, modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& x);
    pair<iterator, bool> insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    void insert(initializer_list<key_type>);
    void insert(sorted_unique_t, initializer_list<key_type>);

    container_type extract() &&;
    void replace(container_type&&);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_set& fs) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
      container_type c;    // \expos
      key_compare compare; // \expos
  };

  template <class Container>
    using @\placeholder{cont-value-type}@ = typename Container::value_type; // \expos
  template<class InputIterator>
    using @\placeholder{iter-value-type}@ = remove_const_t<
      typename iterator_traits<InputIterator>::value_type::first_type>;     // \expos

  template <class Container>
    flat_set(Container)
      -> flat_set<@\placeholder{cont-value-type}@<Container>>;

  template <class Container, class Alloc>
    flat_set(Container, Alloc)
      -> flat_set<@\placeholder{cont-value-type}@<Container>>;

  template <class Container>
    flat_set(sorted_unique_t, Container)
      -> flat_set<@\placeholder{cont-value-type}@<Container>>;

  template <class Container, class Alloc>
    flat_set(sorted_unique_t, Container, Alloc)
      -> flat_set<@\placeholder{cont-value-type}@<Container>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_set(InputIterator, InputIterator, Compare = Compare())
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_set(InputIterator, InputIterator, Compare, Alloc)
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_set(InputIterator, InputIterator, Alloc)
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_set(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_set(sorted_unique_t, InputIterator, InputIterator, Compare, Alloc)
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_set(sorted_unique_t, InputIterator, InputIterator, Alloc)
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>>;

  template<class Key, class Compare = less<Key>>
    flat_set(initializer_list<Key>, Compare = Compare())
      -> flat_set<Key, Compare>;

  template<class Key, class Compare, class Alloc>
    flat_set(initializer_list<Key>, Compare, Alloc)
      -> flat_set<Key, Compare>;

  template<class Key, class Alloc>
    flat_set(initializer_list<Key>, Alloc)
      -> flat_set<Key>;

  template<class Key, class Compare = less<Key>>
    flat_set(sorted_unique_t, initializer_list<Key>, Compare = Compare())
      -> flat_set<Key, Compare>;

  template<class Key, class Compare, class Alloc>
    flat_set(sorted_unique_t, initializer_list<Key>, Compare, Alloc)
      -> flat_set<Key, Compare>;

  template<class Key, class Alloc>
    flat_set(sorted_unique_t, initializer_list<Key>, Alloc)
      -> flat_set<Key>;
}
\end{codeblock}

\rSec3[flatset.cons]{Constructors}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
flat_set(container_type cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{std::move(cont)}, value-initializes
\tcode{compare}, and sorts the range \range{begin()}{end()} with
\tcode{compare}.

\pnum
\complexity
Linear in $N$ if \tcode{cont} is sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_set(InputIterator first, InputIterator last, const key_compare& comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, initializes \tcode{c}
with \range{first}{last}, and sorts the range \range{begin()}{end()}
with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if \range{first}{last} is already sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_set(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp = key_compare());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and initializes
\tcode{c} with \range{first}{last}.

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatset.cons.alloc]{Constructors with allocators}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class Alloc>
  flat_set(const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of
\tcode{c} with \tcode{a}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_set(InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of \tcode{c}
with \tcode{a}; adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if \range{first}{last} is sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_set(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of \tcode{c}
with \tcode{a}; adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatset.modifiers]{Modifiers}

\indexlibrarymember{operator=}{flatset}%
\begin{itemdecl}
flat_set& operator=(initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
clear();
insert(il);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{emplace}{flatset}%
\begin{itemdecl}
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{key_type(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
First, constructs a \tcode{key_type} object \tcode{t} constructed
with \tcode{std::forward<Args>(args)...}.  If the set already contains an
element whose key is equivalent to \tcode{t}, there is no effect.  Otherwise,
equivalent to:
\begin{codeblock}
auto it = lower_bound(c.begin(), c.end(), t);
c.emplace(it, std::move(t));
\end{codeblock}

\pnum
\returns
The \tcode{bool} component of the returned pair is \tcode{true} if and only if
the insertion took place, and the iterator component of the pair points to the
element with key equivalent to the key of \tcode{t}.
\end{itemdescr}

\indexlibrarymember{flatset}{insert}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{flatset}{insert}%
\begin{itemdecl}
void insert(sorted_unique_t, initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{insert(sorted_unique_t{}, il.begin(), il.end())}.
\end{itemdescr}

\indexlibrarymember{flatset}{swap}%
\begin{itemdecl}
void swap(flat_set& fs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<container_type> \&\&
is_nothrow_swappable_v<key_compare>}

\pnum \effects Equivalent to:
\begin{codeblock}
using std::swap;
swap(c, fs.c);
swap(c.compare, fs.compare);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatset}{extract}%
\begin{itemdecl}
container_type extract() &&;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
container_type temp;
temp.swap(c);
return temp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatset}{replace}%
\begin{itemdecl}
void replace(container_type&& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The elements of \tcode{cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c = std::move(cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatset.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator==(const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::equal(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator!=(const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator< (const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator> (const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator<=(const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{flatset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator>=(const flat_set<Key, Compare, Container>& x,
                  const flat_set<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[flatset.special]{Specialized algorithms}

\indexlibrarymember{swap}{flatset}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  void swap(flat_set<Key, Compare, Container>& x,
            flat_set<Key, Compare, Container>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<Container> \&\&
is_nothrow_swappable_v<Compare>}

\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[flatmultiset]{Class template \tcode{flat_multiset}}

\pnum
\indexlibrary{\idxcode{flatmultiset}}%
A \tcode{flat_multiset} is a container adaptor that provides an associative
container interface that supports equivalent keys (possibly containing
multiple copies of the same key value) and provides for fast retrieval of the
keys themselves. The \tcode{flat_multiset} class supports random access
iterators.

\pnum
A \tcode{flat_multiset} satisfies all of the requirements of a container, of a
reversible container (21.2), and of an associative
container (21.2.6), except for the requirements related to
node handles (21.2.4) and iterator
invalidation (21.6.1).  A \tcode{flat_multiset} does
not meet the additional requirements of an allocator-aware container, as
described in Table 80.

\pnum
A \tcode{flat_multiset} also provides most operations described
in~\ref{associative.reqmts} for equal keys.  This means that a
\tcode{flat_multiset} supports the \tcode{a_eq} operations
in~\ref{associative.reqmts} but not the \tcode{a_uniq} operations.  For a
\tcode{flat_multiset<Key>} both the \tcode{key_type} and \tcode{mapped_type} are
\tcode{Key}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_multiset} that
are not described in one of those tables or for operations where there is
additional semantic information.

\pnum
Any sequence container supporting random access iteration can be used to
instantiate \tcode{flat_multiset}. In particular, \tcode{vector} (26.3.11)
and \tcode{deque} (26.3.8) can be used.

\pnum
The template parameter \tcode{Key} shall denote the same type as
\tcode{Container::value_type}.

\pnum
Constructors that take a \tcode{Container} argument \tcode{cont} shall
participate in overload resolution only if both \tcode{std::begin(cont)} and
\tcode{std::end(cont)} are well-formed expressions.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_equivalent_t}
argument with a range that is not sorted with respect to \tcode{compare} is
undefined.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{uses_allocator_v<container_type, Alloc>} is
\tcode{true}.

\pnum
Constructors that take an \tcode{Alloc} argument shall participate in overload
resolution only if \tcode{Alloc} meets the allocator requirements as described
in (21.2.1).

\rSec3[flatmultiset.defn]{Definition}

\begin{codeblock}
template <class Key, class Compare = less<Key>, class Container = vector<Key>>
class flat_multiset {
  public:
    // types
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_multiset::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_multiset::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = Container;

    // \ref{flatmultiset.cons}, construct/copy/destroy
    flat_multiset() : flat_multiset(key_compare()) { }

    explicit flat_multiset(container_type cont);
    template <class Alloc>
      flat_multiset(container_type cont, const Alloc& a)
        : flat_multiset(container_type(std::move(key), a)) { }
    template <class Container>
      explicit flat_multiset(const Container& cont)
        : flat_multiset(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      flat_multiset(const Container& cont, const Alloc& a)
        : flat_multiset(cont.begin(), cont.end(), key_compare(), a) { }

    flat_multiset(sorted_equivalent_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Alloc>
      flat_multiset(sorted_equivalent_t, container_type, const Alloc&)
        : flat_multiset(s, container_type(std::move(cont), a)) { }
    template <class Container>
      flat_multiset(sorted_equivalent_t s, const Container& cont)
        : flat_multiset(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      flat_multiset(sorted_equivalent_t s, const Container& cont, const Alloc& a)
        : flat_multiset(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit flat_multiset(const key_compare& comp)
      : c(container_type()), compare(comp) { }
    template <class Alloc>
      flat_multiset(const key_compare& comp, const Alloc&);
    template <class Alloc>
      explicit flat_multiset(const Alloc& a)
        : flat_multiset(key_compare(), a) { }

    template <class InputIterator>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      flat_multiset(InputIterator first, InputIterator last,
                    const Alloc& a)
        : flat_multiset(first, last, key_compare(), a) { }

    template <class InputIterator>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Alloc>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      flat_multiset(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const Alloc& a)
        : flat_multiset(s, first, last, key_compare(), a) { }

    template <class Alloc>
     flat_multiset(flat_multiset&& m, const Alloc& a)
       : c{container_type(std::move(m.c), a)}
       , compare{std::move(m.compare)}
     { }
   template<class Alloc>
     flat_multiset(const flat_multiset& m, const Alloc& a)
       : c{container_type(m.c, a)}
       , compare{m.compare}
     { }

    flat_multiset(initializer_list<key_type>&& il,
                  const key_compare& comp = key_compare())
      : flat_multiset(il, comp) { }
    template <class Alloc>
      flat_multiset(initializer_list<key_type>&& il,
                    const key_compare& comp, const Alloc& a)
        : flat_multiset(il, comp, a) { }
    template <class Alloc>
      flat_multiset(initializer_list<key_type>&& il, const Alloc& a)
        : flat_multiset(il, key_compare(), a) { }

    flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                  const key_compare& comp = key_compare())
        : flat_multiset(s, il, comp) { }
    template <class Alloc>
      flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                    const key_compare& comp, const Alloc& a)
        : flat_multiset(s, il, comp, a) { }
    template <class Alloc>
      flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                    const Alloc& a)
        : flat_multiset(s, il, key_compare(), a) { }

    flat_multiset& operator=(initializer_list<key_type>);

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // \ref{flatmultiset.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatmultiset.modifiers}, modifiers
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    void insert(initializer_list<key_type>);
    void insert(sorted_equivalent_t, initializer_list<key_type>);

    container_type extract() &&;
    void replace(container_type&&);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_multiset& fms) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
      container_type c;    // \expos
      key_compare compare; // \expos
  };

  template <class Container>
    using @\placeholder{cont-value-type}@ = typename Container::value_type; // \expos
  template<class InputIterator>
    using @\placeholder{iter-value-type}@ = remove_const_t<
      typename iterator_traits<InputIterator>::value_type::first_type>;     // \expos

  template <class Container>
    flat_multiset(Container)
      -> flat_multiset<@\placeholder{cont-value-type}@<Container>>;

  template <class Container, class Alloc>
    flat_multiset(Container, Alloc)
      -> flat_multiset<@\placeholder{cont-value-type}@<Container>>;

  template <class Container>
    flat_multiset(sorted_equivalent_t, Container)
      -> flat_multiset<@\placeholder{cont-value-type}@<Container>>;

  template <class Container, class Alloc>
    flat_multiset(sorted_equivalent_t, Container, Alloc)
      -> flat_multiset<@\placeholder{cont-value-type}@<Container>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_multiset(InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_multiset(InputIterator, InputIterator, Compare, Alloc)
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_multiset(InputIterator, InputIterator, Alloc)
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Compare, class Alloc>
    flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare, Alloc)
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<class InputIterator, class Alloc>
    flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Alloc)
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>>;

  template<class Key, class Compare = less<Key>>
    flat_multiset(initializer_list<Key>, Compare = Compare())
      -> flat_multiset<Key, Compare>;

  template<class Key, class Compare, class Alloc>
    flat_multiset(initializer_list<Key>, Compare, Alloc)
      -> flat_multiset<Key, Compare>;

  template<class Key, class Alloc>
    flat_multiset(initializer_list<Key>, Alloc)
      -> flat_multiset<Key>;

  template<class Key, class Compare = less<Key>>
  flat_multiset(sorted_equivalent_t, initializer_list<Key>, Compare = Compare())
      -> flat_multiset<Key, Compare>;

  template<class Key, class Compare, class Alloc>
    flat_multiset(sorted_equivalent_t, initializer_list<Key>, Compare, Alloc)
      -> flat_multiset<Key, Compare>;

  template<class Key, class Alloc>
  flat_multiset(sorted_equivalent_t, initializer_list<Key>, Alloc)
      -> flat_multiset<Key>;
}
\end{codeblock}

\rSec3[flatmultiset.cons]{Constructors}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
flat_multiset(container_type cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{std::move(cont)}, value-initializes
\tcode{compare}, and sorts the range \range{begin()}{end()} with
\tcode{compare}.

\pnum
\complexity
Linear in $N$ if \tcode{cont} is sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_multiset(InputIterator first, InputIterator last, const key_compare& comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, initializes \tcode{c}
with \range{first}{last}, and sorts the range \range{begin()}{end()}
with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if \range{first}{last} is already sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp = key_compare());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and initializes
\tcode{c} with \range{first}{last}.

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmultiset.cons.alloc]{Constructors with allocators}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class Alloc>
  flat_multiset(const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of
\tcode{c} with \tcode{a}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_multiset(InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of \tcode{c}
with \tcode{a}; adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}
and finally sorts the range \range{begin()}{end()} with \tcode{compare}.

\pnum
\complexity
Linear in $N$ if \range{first}{last} is sorted as if with \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class InputIterator, class Alloc>
  flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{compare} with \tcode{comp}, and performs
uses-allocator construction (23.10.8.2) of \tcode{c}
with \tcode{a}; adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec3[flatmultiset.modifiers]{Modifiers}

\indexlibrarymember{operator=}{flatmultiset}%
\begin{itemdecl}
flat_multiset& operator=(initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
clear();
insert(il);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{emplace}{flatmultiset}%
\begin{itemdecl}
template <class... Args> iterator emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{key_type(std::forward<Args>(args)...)} is well-formed.

\pnum
\effects
First, constructs a \tcode{key_type} object \tcode{t} constructed
with \tcode{std::forward<Args>(args)...}, then inserts \tcode{t} as if by:
\begin{codeblock}
auto it = upper_bound(c.begin(), c.end(), t);
c.emplace(it, std::move(t));
\end{codeblock}

\pnum
\returns
An iterator that points to the inserted element.
\end{itemdescr}

\indexlibrarymember{flatmultiset}{insert}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{flatmultiset}{insert}%
\begin{itemdecl}
void insert(sorted_unique_t, initializer_list<value_type> il);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to \tcode{insert(sorted_unique_t{}, il.begin(), il.end())}.
\end{itemdescr}

\indexlibrarymember{flatmultiset}{swap}%
\begin{itemdecl}
void swap(flat_multiset& fms) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<container_type> \&\&
is_nothrow_swappable_v<key_compare>}

\pnum \effects Equivalent to:
\begin{codeblock}
using std::swap;
swap(c, fms.c);
swap(c.compare, fms.compare);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatmultiset}{extract}%
\begin{itemdecl}
container_type extract() &&;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
container_type temp;
temp.swap(c);
return temp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{flatmultiset}{replace}%
\begin{itemdecl}
void replace(container_type&& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The elements of \tcode{cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c = std::move(cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatmultiset.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator==(const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::equal(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator!=(const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator< (const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator> (const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator<=(const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{flatmultiset}}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  bool operator>=(const flat_multiset<Key, Compare, Container>& x,
                  const flat_multiset<Key, Compare, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[flatmultiset.special]{Specialized algorithms}

\indexlibrarymember{swap}{flatmultiset}%
\begin{itemdecl}
template<class Key, class Compare, class Container>
  void swap(flat_multiset<Key, Compare, Container>& x,
            flat_multiset<Key, Compare, Container>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_nothrow_swappable_v<Container> \&\&
is_nothrow_swappable_v<Compare>}

\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}
\end{addedblock}
