%!TEX root = std.tex
\setcounter{chapter}{21}
\setcounter{section}{6}
\setcounter{subsection}{3}
\rSec2[flatmap.syn]{Header \tcode{<flat_map>} synopsis}%
\indexhdr{flatmap}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // 21.6.9, class template \tcode{flat_map}
  template<class Key, class T, class Compare = less<Key>,
           class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
    class flat_map;

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator==(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator!=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator< (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator> (const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator<=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator>=(const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y);

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@void
    swap(flat_map<Key, T, Compare, KeyContainer, MappedContainer>& x,
         flat_map<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;

  struct sorted_unique_t { explicit sorted_unique_t() = default; };
  inline constexpr sorted_unique_t sorted_unique {};

  // 21.6.10, class template \tcode{flat_multimap}
  template<class Key, class T, class Compare = less<Key>,
           class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
    class flat_multimap;

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator==(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator!=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator< (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator> (const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator<=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);
  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@bool
    operator>=(const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
               const flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y);

  template<class Key, class T, class Compare,
           class KeyContainer, class MappedContainer>
    @\added{constexpr }@void
    swap(flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& x,
         flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& y) noexcept;

  struct sorted_equivalent_t { explicit sorted_equivalent_t() = default; };
  inline constexpr sorted_equivalent_t sorted_equivalent {};
}
\end{codeblock}

\rSec2[flatset.syn]{Header \tcode{<flat_set>} synopsis}%
\indexhdr{flatset}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // 21.6.11, class template \tcode{flat_set}
  template<class Key, class Compare = less<Key>, class Container = vector<Key>>
    class flat_set;

  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator==(const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator!=(const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator< (const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator> (const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator<=(const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator>=(const flat_set<Key, Compare, Container>& x,
                              const flat_set<Key, Compare, Container>& y);

  template<class Key, class Compare, class Container>
    @\added{constexpr }@void swap(flat_set<Key, Compare, Container>& x,
                        flat_set<Key, Compare, Container>& y) noexcept;

  // 21.6.12, class template \tcode{flat_multiset}
  template<class Key, class Compare = less<Key>, class Container = vector<Key>>
    class flat_multiset;

  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator==(const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator!=(const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator< (const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator> (const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator<=(const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);
  template<class Key, class Compare, class Container>
    @\added{constexpr }@bool operator>=(const flat_multiset<Key, Compare, Container>& x,
                              const flat_multiset<Key, Compare, Container>& y);

  template<class Key, class Compare, class Container>
    @\added{constexpr }@void swap(flat_multiset<Key, Compare, Container>& x,
                        flat_multiset<Key, Compare, Container>& y) noexcept;
}
\end{codeblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{9}
\rSec3[flatmap.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_map {
  public:
    // types:
    using key_type                  = Key;
    using mapped_type               = T;
    using value_type                = pair<const key_type, mapped_type>;
    using key_compare               = Compare;
    using reference                 = pair<const key_type&, mapped_type&>;
    using const_reference           = pair<const key_type&, const mapped_type&>;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_map::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_map::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using key_container_type        = KeyContainer;
    using mapped_container_type     = MappedContainer;

    class value_compare {
      friend class flat_map;
    protected:
      key_compare comp;
      @\added{constexpr }@value_compare(key_compare c) : comp(c) { }
    public:
      @\added{constexpr }@bool operator()(const_reference x, const_reference y) const {
        return comp(x.first, y.first);
      }
    };

    struct containers
    {
      key_container_type keys;
      mapped_container_type values;
    };

    // 21.6.9.2, construct/copy/destroy
    @\added{constexpr }@flat_map() : flat_map(key_compare()) { }

    @\added{constexpr }@flat_map(key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    @\added{constexpr }@flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
                       const Alloc& a)
        : flat_map(key_container_type(std::move(key_cont), a),
                   mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      explicit @\added{constexpr }@flat_map(const Container& cont)
        : flat_map(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_map(const Container& cont, const Alloc& a)
        : flat_map(cont.begin(), cont.end(), key_compare(), a) { }

    @\added{constexpr }@flat_map(sorted_unique_t,
                       key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    @\added{constexpr }@flat_map(sorted_unique_t s, key_container_type key_cont,
                       mapped_container_type mapped_cont, const Alloc& a)
        : flat_map(s, key_container_type(std::move(key_cont), a),
                   mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      @\added{constexpr }@flat_map(sorted_unique_t s, const Container& cont)
        : flat_map(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_map(sorted_unique_t s, const Container& cont, const Alloc& a)
        : flat_map(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit @\added{constexpr }@flat_map(const key_compare& comp)
      : c(containers()), compare(comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_map(const key_compare& comp, const Alloc& a);
    template <class Alloc>
      explicit @\added{constexpr }@flat_map(const Alloc& a)
        : flat_map(key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_map(InputIterator first, InputIterator last,
                         const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_map(InputIterator first, InputIterator last,
                         const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_map(InputIterator first, InputIterator last,
                         const Alloc& a)
        : flat_map(first, last, key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_map(sorted_unique_t, InputIterator first, InputIterator last,
                         const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_map(sorted_unique_t, InputIterator first, InputIterator last,
                         const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_map(sorted_unique_t s, InputIterator first, InputIterator last,
                         const Alloc& a)
        : flat_map(s, first, last, key_compare(), a) { }

    template <class Alloc>
      @\added{constexpr }@flat_map(flat_map&& m, const Alloc& a)
        : c{key_container_type(std::move(m.c.keys), a),
            mapped_container_type(std::move(m.c.values), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      @\added{constexpr }@flat_map(const flat_map& m, const Alloc& a)
        : c{key_container_type(m.c.keys, a),
            mapped_container_type(m.c.values, a)}
        , compare{m.compare}
      { }

    @\added{constexpr }@flat_map(initializer_list<value_type>&& il,
                       const key_compare& comp = key_compare())
        : flat_map(il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_map(initializer_list<value_type>&& il,
                         const key_compare& comp, const Alloc& a)
        : flat_map(il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_map(initializer_list<value_type>&& il, const Alloc& a)
        : flat_map(il, key_compare(), a) { }

    @\added{constexpr }@flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
                       const key_compare& comp = key_compare())
        : flat_map(s, il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
                         const key_compare& comp, const Alloc& a)
        : flat_map(s, il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_map(sorted_unique_t s, initializer_list<value_type>&& il,
                         const Alloc& a)
        : flat_map(s, il, key_compare(), a) { }

    @\added{constexpr }@flat_map& operator=(initializer_list<value_type> il);

    // iterators
    @\added{constexpr }@iterator                begin() noexcept;
    @\added{constexpr }@const_iterator          begin() const noexcept;
    @\added{constexpr }@iterator                end() noexcept;
    @\added{constexpr }@const_iterator          end() const noexcept;

    @\added{constexpr }@reverse_iterator        rbegin() noexcept;
    @\added{constexpr }@const_reverse_iterator  rbegin() const noexcept;
    @\added{constexpr }@reverse_iterator        rend() noexcept;
    @\added{constexpr }@const_reverse_iterator  rend() const noexcept;

    @\added{constexpr }@const_iterator          cbegin() const noexcept;
    @\added{constexpr }@const_iterator          cend() const noexcept;
    @\added{constexpr }@const_reverse_iterator  crbegin() const noexcept;
    @\added{constexpr }@const_reverse_iterator  crend() const noexcept;

    // 21.6.9.4, capacity
    [[nodiscard]] @\added{constexpr }@bool empty() const noexcept;
    @\added{constexpr }@size_type size() const noexcept;
    @\added{constexpr }@size_type max_size() const noexcept;

    // 21.6.9.5, element access
    @\added{constexpr }@mapped_type& operator[](const key_type& x);
    @\added{constexpr }@mapped_type& operator[](key_type&& x);
    @\added{constexpr }@mapped_type& at(const key_type& x);
    @\added{constexpr }@const mapped_type& at(const key_type& x) const;

    // 21.6.9.6, modifiers
    template <class... Args>
      @\added{constexpr }@pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator emplace_hint(const_iterator position, Args&&... args);
    @\added{constexpr }@pair<iterator, bool> insert(const value_type& x);
    @\added{constexpr }@pair<iterator, bool> insert(value_type&& x);
    template <class P> @\added{constexpr }@pair<iterator, bool> insert(P&& x);
    @\added{constexpr }@iterator insert(const_iterator position, const value_type& x);
    @\added{constexpr }@iterator insert(const_iterator position, value_type&& x);
    template <class P>
      @\added{constexpr }@iterator insert(const_iterator position, P&&);
    template <class InputIterator>
      @\added{constexpr }@void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      @\added{constexpr }@void insert(sorted_unique_t, InputIterator first, InputIterator last);
    @\added{constexpr }@void insert(initializer_list<value_type>);
    @\added{constexpr }@void insert(sorted_unique_t, initializer_list<value_type> il);

    @\added{constexpr }@containers extract() &&;
    @\added{constexpr }@void replace(key_container_type&& key_cont,
                           mapped_container_type&& mapped_cont);

    template <class... Args>
      @\added{constexpr }@pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template <class... Args>
      @\added{constexpr }@pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator try_emplace(const_iterator hint, const key_type& k,
                           Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template <class M>
      @\added{constexpr }@pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template <class M>
      @\added{constexpr }@pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template <class M>
      @\added{constexpr }@iterator insert_or_assign(const_iterator hint, const key_type& k,
                                          M&& obj);
    template <class M>
      @\added{constexpr }@iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    @\added{constexpr }@iterator erase(iterator position);
    @\added{constexpr }@iterator erase(const_iterator position);
    @\added{constexpr }@size_type erase(const key_type& x);
    @\added{constexpr }@iterator erase(const_iterator first, const_iterator last);

    @\added{constexpr }@void swap(flat_map& fm) noexcept;
    @\added{constexpr }@void clear() noexcept;

    // observers
    @\added{constexpr }@key_compare key_comp() const;
    @\added{constexpr }@value_compare value_comp() const;

    @\added{constexpr }@const key_container_type& keys() const      { return c.keys; }
    @\added{constexpr }@const mapped_container_type& values() const { return c.values; }

    // map operations
    @\added{constexpr }@iterator find(const key_type& x);
    @\added{constexpr }@const_iterator find(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator find(const K& x);
    template <class K> @\added{constexpr }@const_iterator find(const K& x) const;

    @\added{constexpr }@size_type count(const key_type& x) const;
    template <class K> @\added{constexpr }@size_type count(const K& x) const;

    @\added{constexpr }@bool contains(const key_type& x) const;
    template <class K> @\added{constexpr }@bool contains(const K& x) const;

    @\added{constexpr }@iterator lower_bound(const key_type& x);
    @\added{constexpr }@const_iterator lower_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator lower_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator lower_bound(const K& x) const;

    @\added{constexpr }@iterator upper_bound(const key_type& x);
    @\added{constexpr }@const_iterator upper_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator upper_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator upper_bound(const K& x) const;

    @\added{constexpr }@pair<iterator, iterator> equal_range(const key_type& x);
    @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      @\added{constexpr }@pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
    containers c;        // \expos
    key_compare compare; // \expos
  };
}
\end{codeblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{10}
\setcounter{subsubsection}{0}
\rSec3[flatmultimap.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_multimap {
  public:
    // types:
    using key_type                  = Key;
    using mapped_type               = T;
    using value_type                = pair<const key_type, mapped_type>;
    using key_compare               = Compare;
    using reference                 = pair<const key_type&, mapped_type&>;
    using const_reference           = pair<const key_type&, const mapped_type&>;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_multimap::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_multimap::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using key_container_type        = KeyContainer;
    using mapped_container_type     = MappedContainer;

    class value_compare {
      friend class flat_multimap;
    protected:
      key_compare comp;
      @\added{constexpr }@value_compare(key_compare c) : comp(c) { }
    public:
      @\added{constexpr }@bool operator()(const_reference x, const_reference y) const {
        return comp(x.first, y.first);
      }
    };

    struct containers
    {
      key_container_type keys;
      mapped_container_type values;
    };

    // 21.6.10.2, construct/copy/destroy
    @\added{constexpr }@flat_multimap() : flat_multimap(key_compare()) { }

    @\added{constexpr }@flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    @\added{constexpr }@flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
                            const Alloc& a)
        : flat_multimap(key_container_type(std::move(key_cont), a),
                        mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      explicit @\added{constexpr }@flat_multimap(const Container& cont)
        : flat_multimap(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_multimap(const Container& cont, const Alloc& a)
        : flat_multimap(cont.begin(), cont.end(), key_compare(), a) { }

    @\added{constexpr }@flat_multimap(sorted_equivalent_t,
                            key_container_type key_cont, mapped_container_type mapped_cont);
    template <class Alloc>
    @\added{constexpr }@flat_multimap(sorted_equivalent_t, key_container_type key_cont,
                            mapped_container_type mapped_cont, const Alloc& a)
        : flat_multimap(key_container_type(std::move(key_cont), a),
                        mapped_container_type(std::move(mapped_cont), a))
      { }
    template <class Container>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t s, const Container& cont)
        : flat_multimap(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t s, const Container& cont, const Alloc& a)
        : flat_multimap(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit @\added{constexpr }@flat_multimap(const key_compare& comp)
      : c(containers()), compare(comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multimap(const key_compare& comp, const Alloc& a);
    template <class Alloc>
      explicit @\added{constexpr }@flat_multimap(const Alloc& a)
        : flat_multimap(key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_multimap(InputIterator first, InputIterator last,
                              const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multimap(InputIterator first, InputIterator last,
                              const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multimap(InputIterator first, InputIterator last,
                              const Alloc& a)
        : flat_multimap(first, last, key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                              const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                              const key_compare& comp, const Alloc& a);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
                              const Alloc& a)
        : flat_multimap(s, first, last, key_compare(), a) { }

    template <class Alloc>
      @\added{constexpr }@flat_multimap(flat_multimap&& m, const Alloc& a)
        : c{key_container_type(std::move(m.c.keys), a),
            mapped_container_type(std::move(m.c.values), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      @\added{constexpr }@flat_multimap(const flat_multimap& m, const Alloc& a)
        : c{key_container_type(m.c.keys, a), mapped_container_type(m.c.values, a)}
        , compare{m.compare}
      { }

    @\added{constexpr }@flat_multimap(initializer_list<value_type>&& il,
                            const key_compare& comp = key_compare())
        : flat_multimap(il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multimap(initializer_list<value_type>&& il,
                              const key_compare& comp, const Alloc& a)
        : flat_multimap(il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_multimap(initializer_list<value_type>&& il, const Alloc& a)
        : flat_multimap(il, key_compare(), a) { }

    @\added{constexpr }@flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                            const key_compare& comp = key_compare())
        : flat_multimap(s, il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                              const key_compare& comp, const Alloc& a)
        : flat_multimap(s, il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_multimap(sorted_equivalent_t s, initializer_list<value_type>&& il,
                              const Alloc& a)
        : flat_multimap(s, il, key_compare(), a) { }

    @\added{constexpr }@flat_multimap& operator=(initializer_list<value_type> il);

    // iterators
    @\added{constexpr }@iterator                begin() noexcept;
    @\added{constexpr }@const_iterator          begin() const noexcept;
    @\added{constexpr }@iterator                end() noexcept;
    @\added{constexpr }@const_iterator          end() const noexcept;

    @\added{constexpr }@reverse_iterator        rbegin() noexcept;
    @\added{constexpr }@const_reverse_iterator  rbegin() const noexcept;
    @\added{constexpr }@reverse_iterator        rend() noexcept;
    @\added{constexpr }@const_reverse_iterator  rend() const noexcept;

    @\added{constexpr }@const_iterator          cbegin() const noexcept;
    @\added{constexpr }@const_iterator          cend() const noexcept;
    @\added{constexpr }@const_reverse_iterator  crbegin() const noexcept;
    @\added{constexpr }@const_reverse_iterator  crend() const noexcept;

    // capacity
    [[nodiscard]] @\added{constexpr }@bool empty() const noexcept;
    @\added{constexpr }@size_type size() const noexcept;
    @\added{constexpr }@size_type max_size() const noexcept;

    // 21.6.10.5, modifiers
    template <class... Args> @\added{constexpr }@pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator emplace_hint(const_iterator position, Args&&... args);
    @\added{constexpr }@pair<iterator, bool> insert(const value_type& x);
    @\added{constexpr }@pair<iterator, bool> insert(value_type&& x);
    template <class P> @\added{constexpr }@pair<iterator, bool> insert(P&& x);
    @\added{constexpr }@iterator insert(const_iterator position, const value_type& x);
    @\added{constexpr }@iterator insert(const_iterator position, value_type&& x);
    template <class P>
      @\added{constexpr }@iterator insert(const_iterator position, P&&);
    template <class InputIterator>
      @\added{constexpr }@void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      @\added{constexpr }@void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    @\added{constexpr }@void insert(initializer_list<value_type>);
    @\added{constexpr }@void insert(sorted_equivalent_t, initializer_list<value_type> il);

    @\added{constexpr }@containers extract() &&;
    @\added{constexpr }@void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);

    @\added{constexpr }@iterator erase(iterator position);
    @\added{constexpr }@iterator erase(const_iterator position);
    @\added{constexpr }@size_type erase(const key_type& x);
    @\added{constexpr }@iterator erase(const_iterator first, const_iterator last);

    @\added{constexpr }@void swap(flat_multimap& fm) noexcept;
    @\added{constexpr }@void clear() noexcept;

    // observers
    @\added{constexpr }@key_compare key_comp() const;
    @\added{constexpr }@value_compare value_comp() const;

    @\added{constexpr }@const key_container_type& keys() const      { return c.keys; }
    @\added{constexpr }@const mapped_container_type& values() const { return c.values; }

    // map operations
    @\added{constexpr }@iterator find(const key_type& x);
    @\added{constexpr }@const_iterator find(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator find(const K& x);
    template <class K> @\added{constexpr }@const_iterator find(const K& x) const;

    @\added{constexpr }@size_type count(const key_type& x) const;
    template <class K> @\added{constexpr }@size_type count(const K& x) const;

    @\added{constexpr }@bool contains(const key_type& x) const;
    template <class K> @\added{constexpr }@bool contains(const K& x) const;

    @\added{constexpr }@iterator lower_bound(const key_type& x);
    @\added{constexpr }@const_iterator lower_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator lower_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator lower_bound(const K& x) const;

    @\added{constexpr }@iterator upper_bound(const key_type& x);
    @\added{constexpr }@const_iterator upper_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator upper_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator upper_bound(const K& x) const;

    @\added{constexpr }@pair<iterator, iterator> equal_range(const key_type& x);
    @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      @\added{constexpr }@pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
    containers c;        // \expos
    key_compare compare; // \expos
  };
}
\end{codeblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{11}
\setcounter{subsubsection}{0}
\rSec3[flatset.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>, class Container = vector<Key>>
  class flat_set {
  public:
    // types:
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_set::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_set::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = Container;

    // 21.6.11.2, construct/copy/destroy
    @\added{constexpr }@flat_set() : flat_set(key_compare()) { }

    explicit @\added{constexpr }@flat_set(container_type);
    template <class Alloc>
      @\added{constexpr }@flat_set(container_type cont, const Alloc& a)
        : flat_set(container_type(std::move(key), a)) { }
    template <class Container>
      explicit @\added{constexpr }@flat_set(const Container& cont)
        : flat_set(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_set(const Container& cont, const Alloc& a)
        : flat_set(cont.begin(), cont.end(), key_compare(), a) { }

    @\added{constexpr }@flat_set(sorted_unique_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t s, container_type cont, const Alloc& a)
        : flat_set(s, key_container_type(std::move(key_cont), a)) { }
    template <class Container>
      @\added{constexpr }@flat_set(sorted_unique_t s, const Container& cont)
        : flat_set(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t s, const Container& cont, const Alloc& a)
        : flat_set(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit @\added{constexpr }@flat_set(const key_compare& comp)
      : c(container_type()), compare(comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(const key_compare& comp, const Alloc&);
    template <class Alloc>
      explicit @\added{constexpr }@flat_set(const Alloc&) 
        : flat_set(key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_set(InputIterator first, InputIterator last,
                         const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_set(InputIterator first, InputIterator last,
                         const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_set(InputIterator first, InputIterator last, const Alloc& a)
        : flat_set(first, last, key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_set(sorted_unique_t, InputIterator first, InputIterator last,
                         const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t, InputIterator first, InputIterator last,
                         const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t s, InputIterator first, InputIterator last,
                         const Alloc& a)
        : flat_set(s, first, last, key_compare(), a) { }

    template <class Alloc>
      @\added{constexpr }@flat_set(flat_set&& m, const Alloc& a)
        : c{container_type(std::move(m.c), a)}
        , compare{std::move(m.compare)}
      { }
    template<class Alloc>
      @\added{constexpr }@flat_set(const flat_set& m, const Alloc& a)
        : c{container_type(m.c, a)}
        , compare{m.compare}
      { }

    @\added{constexpr }@flat_set(initializer_list<key_type>&& il,
                       const key_compare& comp = key_compare())
        : flat_set(il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(initializer_list<key_type>&& il,
                         const key_compare& comp, const Alloc& a)
        : flat_set(il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(initializer_list<key_type>&& il, const Alloc& a)
        : flat_set(il, key_compare(), a) { }

    @\added{constexpr }@flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
                       const key_compare& comp = key_compare()) 
        : flat_set(s ,il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
                         const key_compare& comp, const Alloc& a) 
        : flat_set(s, il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
                         const Alloc& a)
        : flat_set(s, il, key_compare(), a) { }

    @\added{constexpr }@flat_set& operator=(initializer_list<key_type>);

    // iterators
    @\added{constexpr }@iterator               begin() noexcept;
    @\added{constexpr }@const_iterator         begin() const noexcept;
    @\added{constexpr }@iterator               end() noexcept;
    @\added{constexpr }@const_iterator         end() const noexcept;

    @\added{constexpr }@reverse_iterator       rbegin() noexcept;
    @\added{constexpr }@const_reverse_iterator rbegin() const noexcept;
    @\added{constexpr }@reverse_iterator       rend() noexcept;
    @\added{constexpr }@const_reverse_iterator rend() const noexcept;

    @\added{constexpr }@const_iterator         cbegin() const noexcept;
    @\added{constexpr }@const_iterator         cend() const noexcept;
    @\added{constexpr }@const_reverse_iterator crbegin() const noexcept;
    @\added{constexpr }@const_reverse_iterator crend() const noexcept;

    // 21.6.11.3, capacity
    [[nodiscard]] @\added{constexpr }@bool empty() const noexcept;
    @\added{constexpr }@size_type size() const noexcept;
    @\added{constexpr }@size_type max_size() const noexcept;

    // 21.6.11.4, modifiers
    template <class... Args> @\added{constexpr }@pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator emplace_hint(const_iterator position, Args&&... args);
    @\added{constexpr }@pair<iterator, bool> insert(const value_type& x);
    @\added{constexpr }@pair<iterator, bool> insert(value_type&& x);
    @\added{constexpr }@iterator insert(const_iterator position, const value_type& x);
    @\added{constexpr }@iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      @\added{constexpr }@void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      @\added{constexpr }@void insert(sorted_unique_t, InputIterator first, InputIterator last);
    @\added{constexpr }@void insert(initializer_list<key_type>);
    @\added{constexpr }@void insert(sorted_unique_t, initializer_list<key_type>);

    @\added{constexpr }@container_type extract() &&;
    @\added{constexpr }@void replace(container_type&&);

    @\added{constexpr }@iterator erase(iterator position);
    @\added{constexpr }@iterator erase(const_iterator position);
    @\added{constexpr }@size_type erase(const key_type& x);
    @\added{constexpr }@iterator erase(const_iterator first, const_iterator last);

    @\added{constexpr }@void swap(flat_set& fs) noexcept;
    @\added{constexpr }@void clear() noexcept;

    // observers
    @\added{constexpr }@key_compare key_comp() const;
    @\added{constexpr }@value_compare value_comp() const;

    // set operations
    @\added{constexpr }@iterator find(const key_type& x);
    @\added{constexpr }@const_iterator find(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator find(const K& x);
    template <class K> @\added{constexpr }@const_iterator find(const K& x) const;

    @\added{constexpr }@size_type count(const key_type& x) const;
    template <class K> @\added{constexpr }@size_type count(const K& x) const;

    @\added{constexpr }@bool contains(const key_type& x) const;
    template <class K> @\added{constexpr }@bool contains(const K& x) const;

    @\added{constexpr }@iterator lower_bound(const key_type& x);
    @\added{constexpr }@const_iterator lower_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator lower_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator lower_bound(const K& x) const;

    @\added{constexpr }@iterator upper_bound(const key_type& x);
    @\added{constexpr }@const_iterator upper_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator upper_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator upper_bound(const K& x) const;

    @\added{constexpr }@pair<iterator, iterator> equal_range(const key_type& x);
    @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      @\added{constexpr }@pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
      container_type c;    // \expos
      key_compare compare; // \expos
  };
}
\end{codeblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{12}
\setcounter{subsubsection}{0}
\rSec3[flatmap.defn]{Definition}

\begin{codeblock}
template <class Key, class Compare = less<Key>, class Container = vector<Key>>
class flat_multiset {
  public:
    // types
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_multiset::iterator}}@; // see 21.2
    using const_iterator            = @\impdefx{type of \tcode{flat_multiset::const_iterator}}@; // see 21.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = Container;

    // 21.6.12.2, construct/copy/destroy
    @\added{constexpr }@flat_multiset() : flat_multiset(key_compare()) { }

    explicit @\added{constexpr }@flat_multiset(container_type cont);
    template <class Alloc>
      @\added{constexpr }@flat_multiset(container_type cont, const Alloc& a)
        : flat_multiset(container_type(std::move(key), a)) { }
    template <class Container>
      explicit @\added{constexpr }@flat_multiset(const Container& cont)
        : flat_multiset(cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_multiset(const Container& cont, const Alloc& a)
        : flat_multiset(cont.begin(), cont.end(), key_compare(), a) { }

    @\added{constexpr }@flat_multiset(sorted_equivalent_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t, container_type, const Alloc&)
        : flat_multiset(s, container_type(std::move(cont), a)) { }
    template <class Container>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t s, const Container& cont)
        : flat_multiset(s, cont.begin(), cont.end(), key_compare()) { }
    template <class Container, class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t s, const Container& cont, const Alloc& a)
        : flat_multiset(s, cont.begin(), cont.end(), key_compare(), a) { }

    explicit @\added{constexpr }@flat_multiset(const key_compare& comp)
      : c(container_type()), compare(comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(const key_compare& comp, const Alloc&);
    template <class Alloc>
      explicit @\added{constexpr }@flat_multiset(const Alloc& a)
        : flat_multiset(key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_multiset(InputIterator first, InputIterator last,
                              const key_compare& comp = key_compare());
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multiset(InputIterator first, InputIterator last,
                              const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multiset(InputIterator first, InputIterator last,
                              const Alloc& a)
        : flat_multiset(first, last, key_compare(), a) { }

    template <class InputIterator>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                              const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                              const key_compare& comp, const Alloc&);
    template <class InputIterator, class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t s, InputIterator first, InputIterator last,
                              const Alloc& a)
        : flat_multiset(s, first, last, key_compare(), a) { }

    template <class Alloc>
     @\added{constexpr }@flat_multiset(flat_multiset&& m, const Alloc& a)
       : c{container_type(std::move(m.c), a)}
       , compare{std::move(m.compare)}
     { }
   template<class Alloc>
     @\added{constexpr }@flat_multiset(const flat_multiset& m, const Alloc& a)
       : c{container_type(m.c, a)}
       , compare{m.compare}
     { }

    @\added{constexpr }@flat_multiset(initializer_list<key_type>&& il,
                            const key_compare& comp = key_compare())
      : flat_multiset(il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(initializer_list<key_type>&& il,
                              const key_compare& comp, const Alloc& a)
        : flat_multiset(il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(initializer_list<key_type>&& il, const Alloc& a)
        : flat_multiset(il, key_compare(), a) { }

    @\added{constexpr }@flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                            const key_compare& comp = key_compare())
        : flat_multiset(s, il, comp) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                              const key_compare& comp, const Alloc& a)
        : flat_multiset(s, il, comp, a) { }
    template <class Alloc>
      @\added{constexpr }@flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                              const Alloc& a)
        : flat_multiset(s, il, key_compare(), a) { }

    @\added{constexpr }@flat_multiset& operator=(initializer_list<key_type>);

    // iterators
    @\added{constexpr }@iterator               begin() noexcept;
    @\added{constexpr }@const_iterator         begin() const noexcept;
    @\added{constexpr }@iterator               end() noexcept;
    @\added{constexpr }@const_iterator         end() const noexcept;

    @\added{constexpr }@reverse_iterator       rbegin() noexcept;
    @\added{constexpr }@const_reverse_iterator rbegin() const noexcept;
    @\added{constexpr }@reverse_iterator       rend() noexcept;
    @\added{constexpr }@const_reverse_iterator rend() const noexcept;

    @\added{constexpr }@const_iterator         cbegin() const noexcept;
    @\added{constexpr }@const_iterator         cend() const noexcept;
    @\added{constexpr }@const_reverse_iterator crbegin() const noexcept;
    @\added{constexpr }@const_reverse_iterator crend() const noexcept;

    // 21.6.12.3, capacity
    [[nodiscard]] @\added{constexpr }@bool empty() const noexcept;
    @\added{constexpr }@size_type size() const noexcept;
    @\added{constexpr }@size_type max_size() const noexcept;

    // 21.6.12.4, modifiers
    template <class... Args> @\added{constexpr }@iterator emplace(Args&&... args);
    template <class... Args>
      @\added{constexpr }@iterator emplace_hint(const_iterator position, Args&&... args);
    @\added{constexpr }@iterator insert(const value_type& x);
    @\added{constexpr }@iterator insert(value_type&& x);
    @\added{constexpr }@iterator insert(const_iterator position, const value_type& x);
    @\added{constexpr }@iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      @\added{constexpr }@void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      @\added{constexpr }@void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    @\added{constexpr }@void insert(initializer_list<key_type>);
    @\added{constexpr }@void insert(sorted_equivalent_t, initializer_list<key_type>);

    @\added{constexpr }@container_type extract() &&;
    @\added{constexpr }@void replace(container_type&&);

    @\added{constexpr }@iterator erase(iterator position);
    @\added{constexpr }@iterator erase(const_iterator position);
    @\added{constexpr }@size_type erase(const key_type& x);
    @\added{constexpr }@iterator erase(const_iterator first, const_iterator last);

    @\added{constexpr }@void swap(flat_multiset& fms) noexcept;
    @\added{constexpr }@void clear() noexcept;

    // observers
    @\added{constexpr }@key_compare key_comp() const;
    @\added{constexpr }@value_compare value_comp() const;

    // set operations
    @\added{constexpr }@iterator find(const key_type& x);
    @\added{constexpr }@const_iterator find(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator find(const K& x);
    template <class K> @\added{constexpr }@const_iterator find(const K& x) const;

    @\added{constexpr }@size_type count(const key_type& x) const;
    template <class K> @\added{constexpr }@size_type count(const K& x) const;

    @\added{constexpr }@bool contains(const key_type& x) const;
    template <class K> @\added{constexpr }@bool contains(const K& x) const;

    @\added{constexpr }@iterator lower_bound(const key_type& x);
    @\added{constexpr }@const_iterator lower_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator lower_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator lower_bound(const K& x) const;

    @\added{constexpr }@iterator upper_bound(const key_type& x);
    @\added{constexpr }@const_iterator upper_bound(const key_type& x) const;
    template <class K> @\added{constexpr }@iterator upper_bound(const K& x);
    template <class K> @\added{constexpr }@const_iterator upper_bound(const K& x) const;

    @\added{constexpr }@pair<iterator, iterator> equal_range(const key_type& x);
    @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      @\added{constexpr }@pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      @\added{constexpr }@pair<const_iterator, const_iterator> equal_range(const K& x) const;

  private:
      container_type c;    // \expos
      key_compare compare; // \expos
  };
}
\end{codeblock}
